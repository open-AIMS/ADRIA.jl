"""
    generate_growth_accel_names(biogroup_ids::Vector{Int64})::Array{String, 2}

The format should be growth_accel_<param_name>_<biogroup_id>.

# Returns
Array of dimensions [biogroups ⋅ params]
"""
function generate_growth_accel_names(biogroup_ids::Vector{Int64})::Array{String,2}
    param_names::Tuple{Symbol,Symbol,Symbol} = (:steepness, :height, :midpoint)

    n_params::Int64 = 3
    n_biogroups::Int64 = length(biogroup_ids)

    factor_names::Matrix{String} = Matrix{String}(undef, n_biogroups, n_params)
    for (pn_idx, pn) in enumerate(param_names),
        (bg_idx, bg) in enumerate(biogroup_ids)

        factor_names[bg_idx, pn_idx] = "growth_accel_$(pn)_$(bg)"
    end

    return factor_names
end

"""
    accel_params_array_to_vec(accel_params::AbstractArray{T, 2})::Vector{T} where T <: Union{Float64, String, Tuple}

Convert a 2D array of acceleration parameters to a vector for parameter access.
"""
function accel_params_array_to_vec(
    accel_params::AbstractArray{T,2}
)::Vector{T} where T<:Union{Float64,String,Tuple}
    return vec(accel_params)
end

"""
    accel_params_vec_to_array(accel_params::AbstractVector{T}, n_biogroups::Int64)::Array{T, 2} where T <: Union{Float64, String, Tuple}

Convert a vector of acceleration parameters to a 2D array with dimensions [biogroups ⋅ params].
"""
function accel_params_vec_to_array(
    accel_params::AbstractVector{T},
    n_biogroups::Int64
)::Array{T,2} where T<:Union{Float64,String,Tuple}
    return reshape(accel_params, (n_biogroups, 3))
end

"""
    generate_scale_factor_names(bioregion_ids::Vector{Int64})::Array{String, 3}

Given a list of bioregion IDs, generate the names of the columns corresponding to bioregions.
The format should be biogroup_<id>_<param_name>_<taxa_name>
"""
function generate_scale_factor_names(bioregion_ids::Vector{Int64})::Array{String,3}
    fg_names::Vector{Symbol} = ADRIA.functional_group_names()
    param_names::Tuple{Symbol,Symbol} = (:linear_extension, :mb_rate)

    n_biogroups::Int64 = length(bioregion_ids)
    n_taxa::Int64 = length(fg_names)
    n_type_factors::Int64 = 2

    factor_names::Array{String,3} = Array{String,3}(
        undef, n_taxa, n_type_factors, n_biogroups
    )

    for (bg_idx, bg) in enumerate(bioregion_ids),
        (pn_idx, pn) in enumerate(param_names),
        (fg_idx, fg) in enumerate(fg_names)

        factor_names[fg_idx, pn_idx, bg_idx] = "biogroup_$(string(bg))_$(pn)_$(fg)"
    end

    return factor_names
end

"""
    scale_factor_vec_to_array(sf_vec::AbstractVector{T}, n_taxa::Int64, n_biogroups::Int64, n_p_types::Int64)::Array{T, 3} where T <: Union{Float64, String, Tuple}

Reshape a scale factor vector to be an array of dimensions [taxa ⋅ param_type ⋅ biogroups].
Wrapper of reshape(vec, (n_taxa, n_p_types, n_biogroups)) for consistency. Allow for symbol
arrays to index data frame columns in the correct order.

# Arguments
- `sf_vec` : Flattened scale factor vector. Should be the same order as the underlying data generated by `generate_scale_factor_names`
- `n_taxa` : Number of functional groups or taxanomy classes.
- `n_biogroups` : Number of biogroups sharing scaling factors.
- `n_p_types` : Number of parameters using scale coefficients

# Returns
Matrix of scale factors
"""
function scale_factor_vec_to_array(
    sf_vec::AbstractVector{T}, n_taxa::Int64, n_biogroups::Int64, n_p_types::Int64
)::Array{T,3} where T<:Union{Float64,String,Tuple}
    return reshape(sf_vec, (n_taxa, n_p_types, n_biogroups))
end

"""
    scale_factor_array_to_vec(sf_arr::Array{T, 3})::Vector{T} where T <: Union{Float64, String, Tuple}

Reshape a scale factor array of dimensions [taxa ⋅ param_type ⋅ biogroups] to a flattened
vector. The implementation is a simple wrapper around `vec(sf_arr)` for consistency.
Allows for string arrays to index data frame columns in the correct order.

# Arguments
- `sf_arr` : Scale factor array. Should be the same order as the underlying data generated by `generate_scale_factor_names`

# Returns
Vector of scale factors
"""
function scale_factor_array_to_vec(
    sf_arr::Array{T,3}
)::Vector{T} where {T<:Union{Float64,String,Tuple}}
    return vec(sf_arr)
end

"""
    growth_acceleration(height::Float64, midpoint::Float64, steepness::Float64, available_space::Float64)

Calculate growth acceleration factor based on logistic function of available space.
"""
function growth_acceleration(
    height::Float64, midpoint::Float64, steepness::Float64, available_space::Float64
)
    return height / (1 + exp(-steepness * (available_space - midpoint))) + 1.0
end

"""
    apply_mortality_scaling(mortality::AbstractMatrix, scaling_param::AbstractVector)::AbstractMatrix

Apply scaling to mortality rates based on bioregion-specific parameters.
"""
function apply_mortality_scaling(
    mortality::AbstractMatrix,
    scaling_param::AbstractVector
)::AbstractMatrix
    return mortality .+ 0.5 .* (1 .- mortality) .* scaling_param
end
