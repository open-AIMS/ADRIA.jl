var documenterSearchIndex = {"docs":
[{"location":"development/development_setup/#Development-setup","page":"Development setup","title":"Development setup","text":"","category":"section"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"# Start julia specifying the current directory as the project\n$ julia --project=.\n\n# Instantiate project. Sets up project packages. Only need to do this once.\njulia> ]instantiate","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"For development purposes, set up a sandbox environment (setup only needs to be done once). The steps below assumes you are in the ADRIA.jl project folder.","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"$ mkdir sandbox\n$ cd sandbox\n$ julia\n\n# Switch to package management (`]`) and activate sandbox environment\njulia> ]activate .\n\n# Add ADRIA.jl as a local package under development\n(sandbox) pkg> dev ../\n\n# Add additional debugging tools to sandbox environment\n(sandbox) pkg> add Revise Infiltrator ProfileView BenchmarkTools JET\n\n# Press ctrl+c to exit the package manager","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"Development scripts/functions can then be worked on in the sandbox folder without these polluting the ADRIA project itself.","category":"page"},{"location":"development/development_setup/#Testing","page":"Development setup","title":"Testing","text":"","category":"section"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"To run tests:","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"$ julia --project=.\njulia> ]test ","category":"page"},{"location":"development/development_setup/#Notes","page":"Development setup","title":"Notes","text":"","category":"section"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"The very first import of the ADRIA package will be very slow as it attempts to precompile common functions to reduce later start up time. The same applies when running ADRIA for the first time. This slow initial precompilation has to be repeated if the package is modified, but will remain \"fast\" if no changes are made.","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"To ameliorate this start-up cost while developing, use the Revise package.","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"A custom sysimage can also be created to reduce start up times. See the documentation here for a quick how to. Note: compilation time to create a sysimage can be upwards of 30mins, and has to be repeated if the included packages are to be updated.","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"note: VS Code\nVS Code now has (experimental support) for generating a custom sysimage for its REPL. The same caveats as above apply (it has to be recreated if the project specification has changed for any reason).See: https://www.julia-vscode.org/docs/dev/userguide/compilesysimage/","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"# Timings here were taken with Julia v1.8.1 for ADRIA v0.4.0\n\n# Without custom sysimage\njulia> @time using ADRIA\n 34.289738 seconds (84.97 M allocations: 5.771 GiB, 6.44% gc time, 16.08% compilation time: 74% of which was recompilation)\n\n# With custom sysimage\njulia> @time using ADRIA\n 0.012177 seconds (702 allocations: 40.648 KiB)","category":"page"},{"location":"development/release_guide/#Release-Guide","page":"Release Guide","title":"Release Guide","text":"","category":"section"},{"location":"development/release_guide/#Public-\"Final\"-Releases","page":"Release Guide","title":"Public \"Final\" Releases","text":"","category":"section"},{"location":"development/release_guide/","page":"Release Guide","title":"Release Guide","text":"Run tests locally and ensure all pass.\nEnsure all version numbers have been updated (check Project.toml file)\nSubmit PR from development branch into main and request code review/approval\nOnce PR is merged into main, go to the releases page and draft a new release\nUnder \"choose a tag\" create a new tag \"on publish\"   Note version numbers should follow Semantic Versioning: https://semver.org/\nClick the \"Generate release notes\" button (top-right of textbox).   Under \"Whats new\" add a short description of the major changes.   Explicitly note any major breaking changes (i.e., anything that results obtained with previous versions of ADRIA incompatible)\nRelease title should match the version number.","category":"page"},{"location":"development/release_guide/","page":"Release Guide","title":"Release Guide","text":"Click \"Publish release\" (green button at the bottom)","category":"page"},{"location":"development/release_guide/#Development-Release","page":"Release Guide","title":"Development Release","text":"","category":"section"},{"location":"development/release_guide/","page":"Release Guide","title":"Release Guide","text":"Development releases provide users with the most recent \"working\" version of ADRIA and may still have some known bugs. It provides users a chance to try new features and/or provide feedback before a public release.","category":"page"},{"location":"development/release_guide/","page":"Release Guide","title":"Release Guide","text":"Deploying a Development Release follows the same steps as \"Public\" releases, except:","category":"page"},{"location":"development/release_guide/","page":"Release Guide","title":"Release Guide","text":"Add \"-dev.x\" to the version number.   e.g., v1.2.3-dev.1; v1.2.3-dev.2 for the second development release, etc.\nUntick the \"Set as the latest release\" option and tick the \"Set as a pre-release\" option.","category":"page"},{"location":"development/release_guide/#Release-Candidates","page":"Release Guide","title":"Release Candidates","text":"","category":"section"},{"location":"development/release_guide/","page":"Release Guide","title":"Release Guide","text":"Release candidates are releases that are not yet \"final\" but are close to it. Release candidates provide a \"last chance\" opportunity for users to report bugs prior to a \"final\" release.","category":"page"},{"location":"development/release_guide/","page":"Release Guide","title":"Release Guide","text":"Deploying a Release Candidate follows the same steps as \"Public\" releases, except:","category":"page"},{"location":"development/release_guide/","page":"Release Guide","title":"Release Guide","text":"Add \"-rc.x\" to the version number.   e.g., v1.2.3-rc.1; v1.2.3-rc.2 for the second release candidate, etc.\nUntick the \"Set as the latest release\" option and tick the \"Set as a pre-release\" option.","category":"page"},{"location":"development/building_docs/#Building-Documentation","page":"Building Documentation","title":"Building Documentation","text":"","category":"section"},{"location":"development/building_docs/#Building-documentation-locally","page":"Building Documentation","title":"Building documentation locally","text":"","category":"section"},{"location":"development/building_docs/","page":"Building Documentation","title":"Building Documentation","text":"From the ADRIA project directory:","category":"page"},{"location":"development/building_docs/","page":"Building Documentation","title":"Building Documentation","text":"$ cd docs\n$ julia --project=. make.jl","category":"page"},{"location":"dMCDA/#Dynamic-Multi-Criteria-Decision-Analysis","page":"Dynamic Multi-Criteria Decision Analysis","title":"Dynamic Multi-Criteria Decision Analysis","text":"","category":"section"},{"location":"synopsis/#Synopsis","page":"Synopsis","title":"Synopsis","text":"","category":"section"},{"location":"synopsis/","page":"Synopsis","title":"Synopsis","text":"Climate change is transforming coral reefs. Continued climate change has scope to erode reef biodiversity, key ecosystem functions, and the ecosystem services they provide for people. Conventional management strategies remain essential but will not be sufficient on their own to sustain coral reefs in a warming and acidifying ocean. New interventions are increasingly being considered, including assisted gene flow, cooling and shading, and reef structures that provide reef habitats and substrates for enhanced recruitment.","category":"page"},{"location":"synopsis/","page":"Synopsis","title":"Synopsis","text":"Deciding where, when, and how to intervene – if at all - using new reef restoration and adaptation measures is challenging on at least three fronts.","category":"page"},{"location":"synopsis/","page":"Synopsis","title":"Synopsis","text":"are new interventions likely to create more benefits than damage? And if so, whom do they benefit, or pose risks to, and at what spatial and temporal scales?\nwhich interventions, individually and in combination, represent solutions that provide the highest return on investment for reef, people, and industries?\nwhich R&D paths and deployment strategies represent optimal solutions given multiple key objectives, trade-offs, and limited time, resources, and logistical constraints?","category":"page"},{"location":"synopsis/","page":"Synopsis","title":"Synopsis","text":"To help reef modellers, decision-support teams and reef managers address these questions, AIMS has developed the Adaptive, Dynamic Reef Intervention Algorithm (ADRIA). In short, ADRIA simulates a reef decision maker operating inside the dynamic state space of a coral reef.","category":"page"},{"location":"synopsis/","page":"Synopsis","title":"Synopsis","text":"For reef managers, ADRIA help provide line of sight to conservation solutions in complex settings where multiple objectives need to be considered. For investors, ADRIA helps analysts identify which options (R&D and/or deployment solutions) might have the highest likelihood of providing ecological and social returns on investment. While ADRIA’s key function is as a decision-support tool for intervention deployment, it uses a simple proxy model for reef coral dynamics, consisting of vital rates parameterised in a set of linked differential equations for four coral groups. The growth, mortality and recruitment of those four coral groups are further parameterised by environmental drivers and by different restoration and adaptation interventions.","category":"page"},{"location":"synopsis/","page":"Synopsis","title":"Synopsis","text":"The primary purpose of ADRIA is to help guide intervention deployment such that net benefits are maximised against primary objectives and minimised against costs. Solutions can be tuned (eventually optimised) via heuristics that control the selection of sites and/or reefs and the prioritisation of species, ecosystem services or benefits that favour what people (society) want. The key benefits considered in ADRIA are consistent with a triple-bottom-line approach, i.e.","category":"page"},{"location":"synopsis/","page":"Synopsis","title":"Synopsis","text":"ecological (e.g. biodiversity),\neconomic (e.g. tourism and fisheries values) and\nsocial and cultural (e.g. recreation and supporting identities).","category":"page"},{"location":"synopsis/","page":"Synopsis","title":"Synopsis","text":"The guiding principles for decision support in ADRIA are currently a set of dynamic Multi-Criteria Decision Analyses (dMCDA) applied at each time step. Criteria in the model are a composite of spatial environmental variables (risk from wave damage, thermal stress, and water quality) and ecological information (coral cover, substrate availability).","category":"page"},{"location":"development/architecture/#ADRIA-Architecture","page":"ADRIA Architecture","title":"ADRIA Architecture","text":"","category":"section"},{"location":"#ADRIA.jl-Documentation","page":"ADRIA.jl Documentation","title":"ADRIA.jl Documentation","text":"","category":"section"},{"location":"","page":"ADRIA.jl Documentation","title":"ADRIA.jl Documentation","text":"ADRIA is a multi-criteria decision support platform for informing reef restoration and adaptation interventions.","category":"page"},{"location":"#Quick-start","page":"ADRIA.jl Documentation","title":"Quick start","text":"","category":"section"},{"location":"#Setup","page":"ADRIA.jl Documentation","title":"Setup","text":"","category":"section"},{"location":"","page":"ADRIA.jl Documentation","title":"ADRIA.jl Documentation","text":"To specify user-specific options, a config.toml file should be created with the following options (adjusted to suit your needs):","category":"page"},{"location":"","page":"ADRIA.jl Documentation","title":"ADRIA.jl Documentation","text":"[operation]\nnum_cores = 2     # No. of cores to use. Values <= 0 will use all available cores.\nthreshold = 1e-6  # Result values below this will be set to 0.0\ndebug = false     # Disable multi-processing to allow error messages to be shown\n\n[results]\noutput_dir = \"./Outputs\"  # Change this to point to where you want to store results","category":"page"},{"location":"","page":"ADRIA.jl Documentation","title":"ADRIA.jl Documentation","text":"tip: Performance\nADRIA uses an on-disk data store to hold results from model runs. Setting output_dir to a directory on an SSD (Solid State Drive) will maximize performance.","category":"page"},{"location":"#Usage","page":"ADRIA.jl Documentation","title":"Usage","text":"","category":"section"},{"location":"","page":"ADRIA.jl Documentation","title":"ADRIA.jl Documentation","text":"# Import ADRIA package\nusing ADRIA\n\n\n# Load input dataset (\"Input Set\") for a spatial domain\ndom = ADRIA.load_domain(\"path to Input Set\")\n\n# Generate 100 scenarios based on available environmental data layers and model parameters\nscens = ADRIA.sample(dom, 100)\n\n# Run sampled scenarios for a given RCP\nrs = ADRIA.run_scenarios(scens, dom, \"45\")\n\n# ... or repeatedly run scenarios across several RCPs\nrs = ADRIA.run_scenarios(scens, dom, [\"45\", \"60\", \"85\"])\n\n# then extract metrics for analysis\ntac = ADRIA.metrics.total_absolute_cover(rs)","category":"page"},{"location":"#Troubleshooting-F.A.Q","page":"ADRIA.jl Documentation","title":"Troubleshooting F.A.Q","text":"","category":"section"},{"location":"","page":"ADRIA.jl Documentation","title":"ADRIA.jl Documentation","text":"ADRIA.jl is under active development and from time to time issues may arise. Here are some answers to some issues encountered.","category":"page"},{"location":"","page":"ADRIA.jl Documentation","title":"ADRIA.jl Documentation","text":"Q. I get this warning when trying to load pre-existing results:   Results were produced with a different version of ADRIA (v0.x.x). The installed version of ADRIA is: v0.y.y. Errors may occur when analyzing data.    (where x and y are different numbers).","category":"page"},{"location":"","page":"ADRIA.jl Documentation","title":"ADRIA.jl Documentation","text":"A. The result set being loaded were generated by a different version of ADRIA, and in a possibly incompatible format.   Sometimes, results may still be produced/analyzed as normal. In other times, ADRIA.jl or the expected metadata in the result set may have changed   leading to errors when conducting analyses.","category":"page"},{"location":"","page":"ADRIA.jl Documentation","title":"ADRIA.jl Documentation","text":"Either go back to the version indicated, or re-run the scenarios to obtain results in the updated format.","category":"page"},{"location":"","page":"ADRIA.jl Documentation","title":"ADRIA.jl Documentation","text":"Q. I get an error or warning about an ENV variable not being found or set.","category":"page"},{"location":"","page":"ADRIA.jl Documentation","title":"ADRIA.jl Documentation","text":"A. Double check the configuration settings in config.toml (see above).","category":"page"},{"location":"","page":"ADRIA.jl Documentation","title":"ADRIA.jl Documentation","text":"Q. How do I run my own scenarios?","category":"page"},{"location":"","page":"ADRIA.jl Documentation","title":"ADRIA.jl Documentation","text":"A. Scenarios are defined in a CSV file (with parameter values in columns, so that each row defines a scenario).","category":"page"},{"location":"","page":"ADRIA.jl Documentation","title":"ADRIA.jl Documentation","text":"See the example_scenarios.csv file in the examples directory for an idea of what this looks like.\nSee parameters.jl file in the examples directory on how to extract the model specification and parameter table for a given domain.\nSee also the running_scenarios.jl example script which showcases how to run such a file for a given study area.","category":"page"},{"location":"API/#ADRIA-API","page":"ADRIA API","title":"ADRIA API","text":"","category":"section"},{"location":"API/#Metrics","page":"ADRIA API","title":"Metrics","text":"","category":"section"},{"location":"API/","page":"ADRIA API","title":"ADRIA API","text":"Modules = [ADRIA.metrics]\nOrder   = [:function, :type]","category":"page"},{"location":"API/#ADRIA.metrics._absolute_juveniles-Tuple{AbstractArray{<:Real}, AbstractVector{<:Real}}","page":"ADRIA API","title":"ADRIA.metrics._absolute_juveniles","text":"_absolute_juveniles(X::AbstractArray{<:Real})::AbstractArray{<:Real}\n_absolute_juveniles(rs::ResultSet)::AbstractArray{<:Real}\n\nJuvenile coral cover in m^2.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics._absolute_shelter_volume-Tuple{AbstractArray{<:Real, 4}, Vector{<:Real}, DataFrames.DataFrame}","page":"ADRIA API","title":"ADRIA.metrics._absolute_shelter_volume","text":"_absolute_shelter_volume(X::NamedDimsArray, site_area::Vector{<:Real}, inputs::Union{DataFrame,DataFrameRow})\n_absolute_shelter_volume(rs::ResultSet)\n\nProvide indication of shelter volume in volume of cubic meters.\n\nThe metric applies log-log linear models developed by Urbina-Barreto et al., [1] which uses colony diameter and planar area (2D metrics) to estimate shelter volume (a 3D metric).\n\nArguments\n\nX : raw results\nsite_area : area in m^2 for each site\nmaxcover : maximum possible coral cover for each site (in percentage of sitearea)\ninputs : DataFrame of scenario inputs\n\nReferences\n\nUrbina-Barreto, I., Chiroleu, F., Pinel, R., Fréchon, L., Mahamadaly, V.,   Elise, S., Kulbicki, M., Quod, J.-P., Dutrieux, E., Garnier, R.,   Henrich Bruggemann, J., Penin, L., & Adjeroud, M. (2021). Quantifying the shelter capacity of coral reefs using photogrammetric   3D modeling: From colonies to reefscapes. Ecological Indicators, 121, 107151. https://doi.org/10.1016/j.ecolind.2020.107151\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics._collate_ranks-Tuple{Any, Any}","page":"ADRIA API","title":"ADRIA.metrics._collate_ranks","text":"_collate_ranks(rs, selected)\n\nCollates ranks into seed/shade ranking results into a common structure.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics._colony_Lcm2_to_m3m2-Tuple{Union{DataFrames.DataFrame, DataFrames.DataFrameRow}}","page":"ADRIA API","title":"ADRIA.metrics._colony_Lcm2_to_m3m2","text":"_colony_Lcm2_to_m3_m2(inputs::DataFrame)::Tuple\n\nHelper function to convert coral colony values from Litres/cm² to m³/m²\n\nArguments\n\ninputs : Scenario values for the simulation\n\nReturns\n\nTuple : Assumed colony volume (m³/m²) for each species/size class, theoretical maximum for each species/size class\n\nReferences\n\nUrbina-Barreto, I., Chiroleu, F., Pinel, R., Fréchon, L., Mahamadaly, V., Elise, S., Kulbicki, M., Quod, J.-P.,    Dutrieux, E., Garnier, R., Henrich Bruggemann, J., Penin, L., & Adjeroud, M. (2021).  Quantifying the shelter capacity of coral reefs using photogrammetric 3D modeling:    From colonies to reefscapes.  Ecological Indicators, 121, 107151.  https://doi.org/10.1016/j.ecolind.2020.107151\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics._coral_evenness-Tuple{AbstractArray{<:Real}}","page":"ADRIA API","title":"ADRIA.metrics._coral_evenness","text":"_coral_evenness(X::AbstractArray{<:Real})::AbstractArray{<:Real}\n_coral_evenness(rs::ResultSet)::AbstractArray{<:Real}\n\nCalculates evenness across functional coral groups in ADRIA. Inverse Simpsons diversity indicator.\n\nNotes\n\nNumber of taxa (distinct groups with enhanced lumped with unenhanced) is hardcoded in this function.\n\nReferences\n\nHill, M. O. (1973).   Diversity and Evenness: A Unifying Notation and Its Consequences.  Ecology, 54(2), 427-432. https://doi.org/10.2307/1934352\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics._get_ranks-Tuple{ADRIA.ResultSet, Int64}","page":"ADRIA API","title":"ADRIA.metrics._get_ranks","text":"_get_ranks(rs::ResultSet, intervention::Int64; kwargs...)\n\nExtracts results for a specific intervention (seeding [1] or shading [2])\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics._juvenile_indicator-Tuple{AbstractArray{<:Real}}","page":"ADRIA API","title":"ADRIA.metrics._juvenile_indicator","text":"_juvenile_indicator(X::AbstractArray{<:Real})\n_juvenile_indicator(rs::ResultSet)\n\nIndicator for juvenile density (0 - 1), where 1 indicates the maximum theoretical density  for juveniles have been achieved.\n\nMaximum density is 51.8 juveniles / m², where juveniles are defined as < 5cm diameter.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics._reef_condition_index-Tuple{AbstractArray{<:Real}, AbstractArray{<:Real}, AbstractArray{<:Real}, AbstractArray{<:Real}}","page":"ADRIA API","title":"ADRIA.metrics._reef_condition_index","text":"reef_condition_index(TC, E, SV, juveniles)\nreef_condition_index(rs)\n\nTranslates coral metrics in ADRIA to a Reef Condition Metrics.\n\nNotes\n\nJuveniles are made relative to maximum observed juvenile density (51.8/m²) See email correspondence  from: Dr. A Thompson; to: Dr. K. Anthony Subject: RE: Max density of juvenile corals on the GBR Sent: Friday, 14 October 2022 2:58 PM\n\nArguments\n\nTC        : Total relative coral cover across all groups\nE         : Evenness across four coral groups\nSV        : Shelter volume based coral sizes and abundances\njuveniles : Abundance of coral juveniles < 5 cm diameter\n\nInput dimensions: timesteps, species, sites, repeats, scenarios\n\nReturns\n\nDimensions: timesteps, sites, repeats, scenarios\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics._relative_cover-Tuple{AbstractArray{<:Real}, Vector{<:Real}}","page":"ADRIA API","title":"ADRIA.metrics._relative_cover","text":"_relative_cover(X::AbstractArray{<:Real}, k_area::Vector{<:Real})::AbstractArray{<:Real}\n_relative_cover(rs::ResultSet)::AbstractArray{<:Real}\n\nArguments\n\nX : Matrix of raw model results\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics._relative_juveniles-Tuple{AbstractArray{<:Real}}","page":"ADRIA API","title":"ADRIA.metrics._relative_juveniles","text":"_relative_juveniles(X::AbstractArray{<:Real})::AbstractArray{<:Real}\n_relative_juveniles(rs::ResultSet)::AbstractArray{<:Real}\n\nJuvenile coral cover relative to total site area.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics._relative_shelter_volume-Tuple{AbstractArray{<:Real, 3}, Vector{<:Real}, Vector{<:Real}, Union{DataFrames.DataFrame, DataFrames.DataFrameRow}}","page":"ADRIA API","title":"ADRIA.metrics._relative_shelter_volume","text":"_relative_shelter_volume(X::NamedDimsArray, site_area::Vector{<:Real}, inputs::DataFrame)\n_relative_shelter_volume(rs::ResultSet)\n\nProvide indication of shelter volume relative to theoretical maximum volume for the area covered by coral.\n\nThe metric applies log-log linear models developed by Urbina-Barreto et al., [1] which uses colony diameter and planar area (2D metrics) to estimate shelter volume (a 3D metric).\n\nRSV = begincases\nTASV  MSV  TASV  0 \n0  textotherwise\nendcases\n\nwhere TASV represents Total Absolute Shelter Volume and MSV represents the maximum shelter volume possible.\n\nArguments\n\nX : raw results\nsite_area : area in m^2 for each site\ninputs : DataFrame of scenario inputs\n\nReferences\n\nUrbina-Barreto, I., Chiroleu, F., Pinel, R., Fréchon, L., Mahamadaly, V.,   Elise, S., Kulbicki, M., Quod, J.-P., Dutrieux, E., Garnier, R.,   Henrich Bruggemann, J., Penin, L., & Adjeroud, M. (2021). Quantifying the shelter capacity of coral reefs using photogrammetric   3D modeling: From colonies to reefscapes. Ecological Indicators, 121, 107151. https://doi.org/10.1016/j.ecolind.2020.107151\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics._relative_taxa_cover-Tuple{AbstractArray{<:Real, 3}}","page":"ADRIA API","title":"ADRIA.metrics._relative_taxa_cover","text":"taxa_cover(X::AbstractArray{<:Real})\n\nResults grouped by taxa/species.\n\nTODO: Uses hardcoded index values, to be replaced by something more generic.\n\nArguments\n\nX : Raw model results for a single scenario\n\nReturns\n\nCoral cover, grouped by taxa for the given scenario.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics._shelter_species_loop!-Union{Tuple{T1}, Tuple{AbstractArray{T1, 3}, AbstractArray{T1, 3}, Int64, Any, Any}} where T1","page":"ADRIA API","title":"ADRIA.metrics._shelter_species_loop!","text":"_shelter_species_loop!(X::AbstractArray{T1,3}, ASV::AbstractArray{T1,3}, nspecies::Int64, colony_vol_m3_per_m2, site_area) where {T1}\n\nHelper method to calculate absolute shelter volume metric across each species/size class for a given scenario.\n\nArguments\n\nX : raw results (proportional coral cover relative to full site area)\nASV : matrix to hold shelter volume results\nnspecies : number of species (taxa and size classes) considered\nscen : scenario number to calculate metric for\ncolonyvolm3perm2 : estimated cubic volume per m² of coverage for each species/size class (36)\nsite_area : area of site in m²\nk_area : habitable area of site in m²\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics._shelter_species_loop-Union{Tuple{T1}, Tuple{AbstractArray{T1, 3}, Int64, Array{Float64}, Array{Float64}, Array{Float64}, Array{Float64}}} where T1","page":"ADRIA API","title":"ADRIA.metrics._shelter_species_loop","text":"_shelter_species_loop(X, nspecies::Int64, scen::Int64, colony_vol_m3_per_m2, max_colony_vol_m3_per_m2, site_area)\n\nHelper method to calculate relative shelter volume metric across each species/size class for a given scenario.\n\nNote: Species dimension is an amalgamation of taxa and size class. e.g., X[species=1:6] is Taxa 1, size classes 1-6; X[species=7:12] is Taxa 2, size class 1-6, etc.\n\nArguments\n\nX : raw results (proportional coral cover relative to full site area)\nnspecies : number of species (taxa and size classes) considered\nscen : scenario number to calculate metric for\ncolonyvolm3perm2 : estimated cubic volume per m² of coverage for each species/size class (36)\nmaxcolonyvolm3per_m2 : theoretical maximum volume per m² of coverage for each taxa (6)\nsite_area : total area of site in m²\nk_area : habitable area of site in m² (i.e., k area)\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics._total_absolute_cover-Tuple{AbstractArray{<:Real}, Vector{<:Real}}","page":"ADRIA API","title":"ADRIA.metrics._total_absolute_cover","text":"_total_absolute_cover(X::AbstractArray{<:Real}, site_area::Vector{<:Real})::AbstractArray{<:Real}\n_total_absolute_cover(rs::ResultSet)::AbstractArray{<:Real}\n\nThe Total Absolute Coral Cover. Sum of proportional area taken up by all corals, multiplied by total site area.\n\nArguments\n\nX : Matrix of raw model results\nsite_area : Vector of site areas, with sites following the same order as given indicated in X.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.call_metric-Tuple{Function, NamedDims.NamedDimsArray, Vararg{Any}}","page":"ADRIA API","title":"ADRIA.metrics.call_metric","text":"call_metric(metric, data, args...; timesteps=(:), species=(:), sites=(:), scens=(:))\n\nConvenience method that slices the data in the specified manner.\n\nArguments\n\nmetric : Function, the metric function to apply to \"raw\" data.\ndata    : NamedDimsArray, data to pass into metric\nargs   : Additional positional arguments to pass into metric\ndims   : dummy keyword argument, not used but defined to allow use with other methods\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.coral_cover-Tuple{AbstractArray{<:Real}}","page":"ADRIA API","title":"ADRIA.metrics.coral_cover","text":"coral_cover(X::AbstractArray{<:Real})::NamedTuple\ncoral_cover(rs::ResultSet)\n\nConverts outputs from scenario runs to relative cover of the four different coral taxa.\n\nReturns\n\nNamedTuple     - relativecover : relative coral cover     - enhancedtabacr : cover of enhanced tabular acropora     - unenhancedtabacr : area covered by unenhanced tabular acropora     - enhancedcoracr : area covered by enhanced corymbose acropora     - unenhancedcoracr : area covered by unenhanced corymbose acropora     - tabacr : cover of tabular acropora     - coracr : cover of corymbose acropora     - smallenc : cover of small encrusting     - large_mass : cover of large massives     - juveniles : area covered by juveniles     - large : area covered by large mature corals\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.dims-Tuple{ADRIA.metrics.Metric}","page":"ADRIA API","title":"ADRIA.metrics.dims","text":"dims(m::Metric)::Tuple\n\nGet dimension names for a given outcome/metric.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.dominates-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}}","page":"ADRIA API","title":"ADRIA.metrics.dominates","text":"dominates(x::Vector{<:Real}, y::Vector{<:Real})::Vector\n\nAdapted from: https://discourse.julialang.org/t/fast-optimized-non-dominated-sorting-algorithms/86793/7\n\nOriginal function name is dominates2()\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.metric_name-Tuple{ADRIA.metrics.Metric}","page":"ADRIA API","title":"ADRIA.metrics.metric_name","text":"metric_name(m::Metric)::String\n\nGet name of metric as a string.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.nds","page":"ADRIA API","title":"ADRIA.metrics.nds","text":"nds(X::AbstractArray{<:Real}, dist::Int64=0)::Vector{Vector{<:Int}}\n\nNaive n-dimensional non-dominated sorting.\n\nAdapted from: https://discourse.julialang.org/t/fast-optimized-non-dominated-sorting-algorithms/86793/7\n\nOriginal function name is nds4()\n\nArguments\n\nX : outcomes, where rows are scenarios and columns are metric results. dist : distance from front, where 0 is on the frontier.\n\nReturns\n\nVector of Vectors with row indices for each dist from frontier, where 0 is on the frontier.\n\n\n\n\n\n","category":"function"},{"location":"API/#ADRIA.metrics.per_site-Tuple{Any, NamedDims.NamedDimsArray}","page":"ADRIA API","title":"ADRIA.metrics.per_site","text":"per_site(metric, data::NamedDimsArray)\n\nGet metric results applied to the site-level at indicated time (or across timesteps).\n\nArguments\n\nmetric : Any function from the Statistics package to be applied to data\ndata : Data set to apply metric to\ntimestep : Target time step, or time frame\n\nReturns\n\nVector of N elements, where N is the number of sites.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.scenario_asv-Tuple{NamedDims.NamedDimsArray}","page":"ADRIA API","title":"ADRIA.metrics.scenario_asv","text":"scenario_asv(sv::NamedDimsArray; kwargs...)\nscenario_asv(rs::ResultSet; kwargs...)\n\nCalculate the cluster-wide absolute shelter volume for each scenario.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.scenario_juveniles-Tuple{NamedDims.NamedDimsArray}","page":"ADRIA API","title":"ADRIA.metrics.scenario_juveniles","text":"scenario_juveniles(data::NamedDimsArray; kwargs...)\n\nCalculate the cluster-wide juvenile population for individual scenarios.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.scenario_relative_cover-Tuple{ADRIA.ResultSet}","page":"ADRIA API","title":"ADRIA.metrics.scenario_relative_cover","text":"scenario_relative_cover(rs::ResultSet; kwargs...)\n\nCalculate the cluster-wide relative coral cover for each scenario.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.scenario_rsv-Tuple{NamedDims.NamedDimsArray}","page":"ADRIA API","title":"ADRIA.metrics.scenario_rsv","text":"scenario_rsv(sv::NamedDimsArray; kwargs...)\nscenario_rsv(rs::ResultSet; kwargs...)\n\nCalculate the cluster-wide mean relative shelter volumes for each scenario.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.scenario_total_cover-Tuple{ADRIA.ResultSet}","page":"ADRIA API","title":"ADRIA.metrics.scenario_total_cover","text":"scenario_total_cover(rs::ResultSet; kwargs...)\n\nCalculate the cluster-wide total absolute coral cover for each scenario.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.seed_ranks-Tuple{ADRIA.ResultSet}","page":"ADRIA API","title":"ADRIA.metrics.seed_ranks","text":"seed_ranks(rs::ResultSet; kwargs...)\n\nArguments\n\nrs : ResultSet\nkwargs : named dimensions to slice across\n\nReturns\n\nNamedArray[timesteps, sites, scenarios]\n\nExample\n\nADRIA.metrics.seed_ranks(rs; timesteps=1:10, scenarios=3:5)\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.shade_ranks-Tuple{ADRIA.ResultSet}","page":"ADRIA API","title":"ADRIA.metrics.shade_ranks","text":"shade_ranks(rs::ResultSet; kwargs...)\n\nArguments\n\nrs : ResultSet\nkwargs : named dimensions to slice across\n\nReturns\n\nNamedArray[timesteps, sites, scenarios]\n\nExample\n\nADRIA.metrics.shade_ranks(rs; timesteps=1:10, scenarios=3:5)\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.slice_results-Tuple{NamedDims.NamedDimsArray}","page":"ADRIA API","title":"ADRIA.metrics.slice_results","text":"slice_results(data::NamedDimsArray; timesteps=(:), species=(:), sites=(:), scenarios=(:))\n\nSlice data as indicated. Dimensions not found in target data are ignored.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.summarize_absolute_shelter_volume-Tuple{NamedDims.NamedDimsArray}","page":"ADRIA API","title":"ADRIA.metrics.summarize_absolute_shelter_volume","text":"summarize_absolute_shelter_volume(sv::AbstractArray{<:Real}, kwargs...)::Dict{Symbol,AbstractArray{<:Real}}\nsummarize_absolute_shelter_volume(rs::ResultSet, kwargs...)::Dict{Symbol,AbstractArray{<:Real}}\n\nCalculate summarized coral evenness.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.summarize_coral_evenness-Tuple{NamedDims.NamedDimsArray}","page":"ADRIA API","title":"ADRIA.metrics.summarize_coral_evenness","text":"summarize_coral_evenness(raw::AbstractArray{<:Real}, kwargs...)::Dict{Symbol,AbstractArray{<:Real}}\nsummarize_coral_evenness(rs::ResultSet, kwargs...)::Dict{Symbol,AbstractArray{<:Real}}\n\nCalculate summarized coral evenness.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.summarize_raw-Tuple{NamedDims.NamedDimsArray}","page":"ADRIA API","title":"ADRIA.metrics.summarize_raw","text":"summarize_raw(data::NamedDimsArray; kwargs...)::Dict{Symbol,AbstractArray{<:Real}}\n\nSummarize raw data, aggregating the specified dimensions (e.g., timesteps, scenarios, etc.) and collapsing given dims.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.summarize_relative_cover-Tuple{NamedDims.NamedDimsArray}","page":"ADRIA API","title":"ADRIA.metrics.summarize_relative_cover","text":"summarize_relative_cover(rc::AbstractArray{<:Real}, kwargs...)::Dict{Symbol,AbstractArray{<:Real}}\nsummarize_relative_cover(rs::ResultSet, kwargs...)::Dict{Symbol,AbstractArray{<:Real}}\n\nCalculate summarized relative cover.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.summarize_relative_shelter_volume-Tuple{NamedDims.NamedDimsArray}","page":"ADRIA API","title":"ADRIA.metrics.summarize_relative_shelter_volume","text":"summarize_relative_shelter_volume(sv::AbstractArray{<:Real}, kwargs...)::Dict{Symbol,AbstractArray{<:Real}}\nsummarize_relative_shelter_volume(rs::ResultSet, kwargs...)::Dict{Symbol,AbstractArray{<:Real}}\n\nCalculate summarized coral evenness.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.summarize_total_cover-Tuple{NamedDims.NamedDimsArray, AbstractArray{<:Real}}","page":"ADRIA API","title":"ADRIA.metrics.summarize_total_cover","text":"summarize_total_cover(raw::AbstractArray{<:Real}, areas::AbstractArray{<:Real}; kwargs...)::Dict{Symbol,AbstractArray{<:Real}}\nsummarize_total_cover(rs::ResultSet; kwargs...)::Dict{Symbol,AbstractArray{<:Real}}\n\nCalculate summarized total absolute cover.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.top_N_sites-Tuple{ADRIA.ResultSet, Int64}","page":"ADRIA API","title":"ADRIA.metrics.top_N_sites","text":"top_N_sites(rs::ResultSet; N::Int64; metric::relative_cover)\ntop_N_sites(data::AbstractArray{Real}, N::Int64; stat=mean)\n\nReturn the top N sites according to the provided metric (defaulting to mean of relative_cover).\n\nArguments\n\nrs : ResultSet\nN : No. of best performing sites to be selected\nmetric : metric to use to order sites from best to worst,          must take ResultSet as input\nstat : summary statistic to use for comparison (default: mean)\n\nReturns\n\nNamedDimsArray[:scenarios,:siteids], where `siteids` indicates order of site ranking as well.\n\nExample\n\nADRIA.metrics.top_N_sites(rs, 5)\nADRIA.metrics.top_N_sites(rs, 5; metric=ADRIA.metric.relative_cover)\nADRIA.metrics.top_N_sites(rs, 5; metric=ADRIA.metric.relative_cover, stat=median)\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.top_n_seeded_sites-Tuple{ADRIA.ResultSet, Int64}","page":"ADRIA API","title":"ADRIA.metrics.top_n_seeded_sites","text":"top_n_seeded_sites(rs::ResultSet, n::Int64; kwargs...)\n\nGet the top n seeded sites over time by their unique site id. Lower rank values are better (e.g., 1 = first choice)\n\nArguments\n\nrs : ResultSet\nn : n sites to retrieve\nkwargs : dimensions to slice across\n\nReturns\n\nNamedDimsArray[sites, [Site Index, Unique ID, Rank], scenarios]\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.trajectory_heatmap-Tuple{NamedDims.NamedDimsArray}","page":"ADRIA API","title":"ADRIA.metrics.trajectory_heatmap","text":"trajectory_heatmap(data::Matrix{Float64})::Tuple{Vector{Float64}, Vector{Float64}, Matrix{Int64}}\n\nEstimate heatmap of trajectories from a 2D dataset.\n\nArguments\n\ndata : An N*D matrix where N is time steps and D is the scenario outcome for the given timestep in N\n\nReturns\n\nOnlineStats.HeatMap\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.trajectory_heatmap_data-Tuple{NamedDims.NamedDimsArray}","page":"ADRIA API","title":"ADRIA.metrics.trajectory_heatmap_data","text":"trajectory_heatmap_data(data::Matrix{Float64})::Tuple{Vector{Float64}, Vector{Float64}, Matrix{Int64}}\n\nEstimate heatmap of trajectories from a 2D dataset.\n\nArguments\n\ndata : An N*D matrix where N is time steps and D is the scenario outcome for the given timestep in N\n\nReturns\n\nTuple of xedges, yedges, and bi-dimensional histogram matrix\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.ndims-Tuple{ADRIA.metrics.Metric}","page":"ADRIA API","title":"Base.ndims","text":"ndims(m::Metric)::Int64\n\nInfer the number of dimensions for a given outcome/metric.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.Metric-Tuple{Any, Vararg{Any}}","page":"ADRIA API","title":"ADRIA.metrics.Metric","text":"Make Metric callable with arbitary arguments that are passed to associated function.\n\n\n\n\n\n","category":"method"},{"location":"API/#Performance-indicators","page":"ADRIA API","title":"Performance indicators","text":"","category":"section"},{"location":"API/","page":"ADRIA API","title":"ADRIA API","text":"Modules = [ADRIA.performance]\nOrder   = [:function, :type]","category":"page"},{"location":"API/#ADRIA.performance.RMSE-Tuple{Any, Any}","page":"ADRIA API","title":"ADRIA.performance.RMSE","text":"Root Mean Square Error\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.performance.environmental_diversity-Tuple{Any, Any}","page":"ADRIA API","title":"ADRIA.performance.environmental_diversity","text":"environmental_diversity(ms, inputs_i)\n\nObtain an indication of environmental factor diversity for a scenario set. Higher values indicate a greater of mix of environmental conditions were experienced between scenarios.\n\nThis is referred to as E.\n\nArguments\n\nms : model spec\ninputs_i : inputs used for scenarios of interest\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.performance.gmd-Tuple{AbstractVector{<:Real}}","page":"ADRIA API","title":"ADRIA.performance.gmd","text":"gmd(vals::AbstractVector{<:Real})::Float64\ngmd(vals::AbstractMatrix{<:Real})\n\nGini's Mean Difference.\n\nThe absolute mean of all pairwise distances between elements in a given set.\n\nReferences\n\nLa Haye, R., & Zizler, P. (2019).  The Gini mean difference and variance.  METRON, 77(1), 43-52.  https://doi.org/10.1007/s40300-019-00149-2\nYitzhaki, S. (2003).  Gini's Mean difference: A superior measure of variability for non-normal   distributions.  Metron - International Journal of Statistics, LXI(2), 285-316. https://ideas.repec.org/a/mtn/ancoec/030208.html\nKashif, M., Aslam, M., Al-Marshadi, A. H., & Jun, C.-H. (2016). Capability Indices for Non-Normal Distribution Using Gini's Mean Difference as Measure of Variability.  IEEE Access, 4, 7322-7330. https://doi.org/10.1109/ACCESS.2016.2620241\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.performance.intervention_diversity-Tuple{Any, Any}","page":"ADRIA API","title":"ADRIA.performance.intervention_diversity","text":"intervention_diversity(ms, inputs_i)\n\nObtain an indication of intervention diversity for a scenario. Higher values indicate a greater of mix of interventions options were applied.\n\nThis is referred to as D.\n\nArguments\n\nms : model spec\ninputs_i : inputs used for scenarios of interest\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.performance.intervention_effort-Tuple{Any, Any, Any}","page":"ADRIA API","title":"ADRIA.performance.intervention_effort","text":"intervention_effort(ms, inputs_i)\n\nObtain an indication of intervention effort for each scenario and intervention type. This is referred to as F.\n\nArguments\n\nms : model spec\ninputs_i : inputs used for scenarios of interest\n\nReturns\n\nMatrix of s * 6, where s is the number of scenarios and columns are: seed_TA, seed_CA, fogging, SRM, seed_years, shade_years\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.performance.normalize-Tuple{AbstractArray{<:Real}}","page":"ADRIA API","title":"ADRIA.performance.normalize","text":"normalize(vals::AbstractArray{<:Real})\n\nNormalize values using feature scaling such that values are bound between 0 and 1, where 1 is equivalent to the maximum value found.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.performance.probability-Tuple{AbstractArray{<:Real}}","page":"ADRIA API","title":"ADRIA.performance.probability","text":"probability(vals::AbstractArray{<:Real})\n\nCalculate probability of individual trajectories, given a scenario ensemble S.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.performance.temporal_variability-Tuple{AbstractVector{<:Real}}","page":"ADRIA API","title":"ADRIA.performance.temporal_variability","text":"temporal_variability(x::AbstractVector{<:Real})\ntemporal_variability(x::AbstractArray{<:Real, 2})\ntemporal_variability(x::AbstractArray{<:Real}, func_or_data...)\n\nThe V meta-metric.\n\nAs a meta-metric, it can be applied to any combination of metrics (including itself), assuming x is bound between 0 and 1. If this is not the case, consider normalizing values first.\n\nExamples\n\n# Apply V to a time series\njulia> temporal_variability(rand(50))\n\n# Apply V to an ensemble of of time series\njulia> x = rand(50, 200)\njulia> temporal_variability(x)\n\n# Create and apply a modified V metric to an ensemble of of time series.\n# Where the argument is an array and not a function, the data is used directly\n# and so it is assumed all matrices are of the same size and shape.\njulia> temporal_variability(x, temporal_variabilty, temporal_variability(P(x)))\njulia> temporal_variability(x, temporal_variabilty, P(x), D(x), E(x))\n\n\n\n\n\n","category":"method"},{"location":"API/#Sensitivity","page":"ADRIA API","title":"Sensitivity","text":"","category":"section"},{"location":"API/","page":"ADRIA API","title":"ADRIA API","text":"Modules = [ADRIA.sensitivity]\nOrder   = [:function, :type]","category":"page"},{"location":"API/#ADRIA.sensitivity.ks_statistic-Tuple{Any}","page":"ADRIA API","title":"ADRIA.sensitivity.ks_statistic","text":"ks_statistic(ks)\n\nCalculate the Kolmogorov-Smirnov test statistic.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.sensitivity.pawn-Tuple{AbstractArray{<:Real}, Vector{<:Real}, Vector{String}}","page":"ADRIA API","title":"ADRIA.sensitivity.pawn","text":"Calculates the PAWN sensitivity index.\n\nArguments\n\nX : Model inputs\nY : Outputs\nS : Number of slides (default: 10)\n\nReturns\n\nNamedDimsArray, of min, mean, median, max, std, and cv summary statistics.\n\nReferences\n\nPianosi, F., Wagener, T., 2018. Distribution-based sensitivity analysis from a generic input-output sample. Environmental Modelling & Software 108, 197-207. https://doi.org/10.1016/j.envsoft.2018.07.019\nBaroni, G., Francke, T., 2020. GSA-cvd Combining variance- and distribution-based global sensitivity analysis https://github.com/baronig/GSA-cvd\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.sensitivity.relative_importance-Tuple{AbstractVector{<:Real}}","page":"ADRIA API","title":"ADRIA.sensitivity.relative_importance","text":"relative_importance(x::AbstractVector{<:Real})\nrelative_importance(x::AbstractArray)\n\nNormalize metrics such that the values ∈ [0, 1].\n\nNote: If a matrix is passed in, this calculates the relative importance for each column.\n\nArguments\n\nx : metric values\n\nReturns\n\nNormalized values of same shape as x.\n\n\n\n\n\n","category":"method"},{"location":"API/#General-API","page":"ADRIA API","title":"General API","text":"","category":"section"},{"location":"API/","page":"ADRIA API","title":"ADRIA API","text":"Modules = [ADRIA]\nOrder   = [:function, :type]","category":"page"},{"location":"API/#ADRIA.RCP_to_SSP-Tuple{String}","page":"ADRIA API","title":"ADRIA.RCP_to_SSP","text":"RCP_to_SSP(rcp)\n\nConvert RCP scenarios to SSP scenarios.\n\nArguments:\n\nrcp::String: RCP scenario identifier\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA._char_to_string-Tuple{Any}","page":"ADRIA API","title":"ADRIA._char_to_string","text":"_char_to_string(vals)::Vector{String}\n\nConvert character array entries in netCDFs to string.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA._check_bounds-Tuple{Any, Any}","page":"ADRIA API","title":"ADRIA._check_bounds","text":"Check specified bounds for validity.\n\nRaises error if lower bound values are greater than upper bounds.\n\nArguments\n\nlower : lower bounds\nupper : upper bound values\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA._check_compat-Tuple{Dict}","page":"ADRIA API","title":"ADRIA._check_compat","text":"_check_compat(dpkg_details::Dict)\n\nChecks for version compatibility.\n\nArguments\n\ndpkg_details : Datapackage spec\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA._copy_env_stats-Tuple{String, String, String}","page":"ADRIA API","title":"ADRIA._copy_env_stats","text":"_copy_env_stats(src::String, dst::String, subdir::String)::Nothing\n\nHelper function to copy environmental data layer statistics from data store.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA._coral_struct-Tuple{Dict}","page":"ADRIA API","title":"ADRIA._coral_struct","text":"coralstruct(field_defs::Dict)::Nothing\n\nHelper function to dynamically create structs\n\nhttps://stackoverflow.com/a/27084705/2694952 https://stackoverflow.com/questions/27083816/is-it-possible-to-create-types-in-julia-at-runtime\n\nExample\n\n# Generate Coral struct with single attribute \"a\"\n_coral_struct(Dict(\"a\"=>200))\n\ny = Coral()\n# Coral{Int64}(200)\n\ny.a\n# 200\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA._load_dpkg-Tuple{String}","page":"ADRIA API","title":"ADRIA._load_dpkg","text":"_load_dpkg(dpkg_path::String)\n\nLoad and parse datapackage.\n\nArguments\n\ndpkg_path : path to datapackage\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA._recreate_stats_from_store-Tuple{String}","page":"ADRIA API","title":"ADRIA._recreate_stats_from_store","text":"_recreate_stats_from_store(zarr_store_path::String)::Dict{String, AbstractArray}\n\nRecreate data structure holding RCP summary statistics from Zarr store.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA._remove_workers-Tuple{}","page":"ADRIA API","title":"ADRIA._remove_workers","text":"Remove workers and free up memory.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA._setup_workers-Tuple{}","page":"ADRIA API","title":"ADRIA._setup_workers","text":"Spin up workers if needed.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.adjust_samples-Tuple{Domain, DataFrames.DataFrame}","page":"ADRIA API","title":"ADRIA.adjust_samples","text":"adjust_samples(d::Domain, df::DataFrame)::DataFrame\nadjust_samples!(d::Domain, spec::DataFrame, df::DataFrame)::DataFrame\n\nAdjust given samples to ensure parameter value combinations for unguided scenarios are plausible.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.align_rankings!-Tuple{Array, Matrix, Int64}","page":"ADRIA API","title":"ADRIA.align_rankings!","text":"align_rankings!(rankings::Array, s_order::Matrix, col::Int64)::Nothing\n\nAlign a vector of site rankings to match the indicated order in s_order.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.bleaching_mortality!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractArray{Float64}, Int64, Vector{Float64}, Vector{Float64}, AbstractArray{Float64}, Vector{Float64}, Real}","page":"ADRIA API","title":"ADRIA.bleaching_mortality!","text":"bleaching_mortality!(Y::Matrix{Float64}, tstep::Int64, depth::Vector{Float64},\n    s::Vector{Float64}, dhw::Float64, a_adapt::Float64, n_adapt::Float64)\n\nCalculates bleaching mortality taking into account depth and bleaching sensitivity of corals. Model is adapted from Bozec et al., [2], itself based on data from Hughes et al., 3 and Baird et al., 1.\n\nArguments\n\nY : Matrix to save results into\ntstep : Current time step\ndepth : Mean site depth (m) for each site\ns : Bleaching sensitivity of corals (relative values) for each taxa/size class\ndhw : Degree Heating Week experienced at site\na_adapt : Level of assisted adaptation (DHW reduction)\nn_adapt : Level of natural adaptation (DHW reduction linearly scaled over time)\n\nReturns\n\nNothing\n\nReferences\n\nBaird, A., Madin, J., Álvarez-Noriega, M., Fontoura, L., Kerry, J., Kuo, C.,   Precoda, K., Torres-Pulliza, D., Woods, R., Zawada, K., & Hughes, T. (2018). A decline in bleaching suggests that depth can provide a refuge from global   warming in most coral taxa. Marine Ecology Progress Series, 603, 257-264. https://doi.org/10.3354/meps12732\nBozec, Y.-M., Hock, K., Mason, R. A. B., Baird, M. E., Castro-Sanguino, C.,   Condie, S. A., Puotinen, M., Thompson, A., & Mumby, P. J. (2022). Cumulative impacts across Australia's Great Barrier Reef: A mechanistic evaluation. Ecological Monographs, 92(1), e01494. https://doi.org/10.1002/ecm.1494\nHughes, T. P., Kerry, J. T., Baird, A. H., Connolly, S. R., Dietzel, A., Eakin, C. M.,   Heron, S. F., Hoey, A. S., Hoogenboom, M. O., Liu, G., McWilliam, M. J., Pears, R. J.,   Pratchett, M. S., Skirving, W. J., Stella, J. S., & Torda, G. (2018). Global warming transforms coral reef assemblages. Nature, 556(7702), 492-496. https://doi.org/10.1038/s41586-018-0041-2\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.centroids-Tuple{DataFrames.DataFrame}","page":"ADRIA API","title":"ADRIA.centroids","text":"centroids(df::DataFrame)\n\nExtract and return long/lat from a GeoDataFrame.\n\nArguments\n\ndf : GeoDataFrame\n\nReturns\n\nArray of tuples (x, y), where x and y relate to long and lat respectively.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.colony_areas-Tuple{}","page":"ADRIA API","title":"ADRIA.colony_areas","text":"colony_areas()\n\nGenerate colony area data based on Bozec et al., [1].\n\nReturns\n\ncolonyareamean_cm2 : mean colony areas in cm²\ncolonydiammeans_m : mean colony diameter (in meters)\n\nReferences\n\nBozec, Y.-M., Rowell, D., Harrison, L., Gaskell, J., Hock, K.,   Callaghan, D., Gorton, R., Kovacs, E. M., Lyons, M., Mumby, P.,   & Roelfsema, C. (2021).     Baseline mapping to support reef restoration and resilience-based     management in the Whitsundays.   https://doi.org/10.13140/RG.2.2.26976.20482\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.combine_results-Tuple","page":"ADRIA API","title":"ADRIA.combine_results","text":"combine(result_sets...)::ResultSet\ncombine_results(result_set_locs::Array{String})::ResultSet\n\nCombine arbitrary number of ADRIA result sets into a single data store.\n\nNote: Results are stored in Zarr format. Combining data sets can be       expected to double total disk space requirement.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.component_params-Tuple{ADRIA.ResultSet, Type}","page":"ADRIA API","title":"ADRIA.component_params","text":"component_params(spec::DataFrame, component::Type)::DataFrame\n\nExtract parameters for a specific model component from exported model specification.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.component_params-Tuple{ModelParameters.Model, Type}","page":"ADRIA API","title":"ADRIA.component_params","text":"component_params(m::Model, component::Type)::DataFrame\ncomponent_params(spec::DataFrame, component::Type)::DataFrame\ncomponent_params(m::Model, components::Vector)::DataFrame\ncomponent_params(spec::DataFrame, components::Vector)::DataFrame\n\nExtract parameters for a specific model component.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.connectivity_strength-Tuple{AbstractArray}","page":"ADRIA API","title":"ADRIA.connectivity_strength","text":"connectivity_strength(TP_base::AbstractArray)::NamedTuple\n\nGenerate array of outdegree connectivity strength for each node and its strongest predecessor.\n\nReturns\n\nNamedTuple:\n\nin_conn : sites ranked by incoming connectivity\nout_conn : sites ranked by outgoing connectivity\nstrongest_predecessor : strongest predecessor for each site\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.coral_spec-Tuple{}","page":"ADRIA API","title":"ADRIA.coral_spec","text":"coral_spec()\n\nTemplate for coral parameter values for ADRIA. Includes \"vital\" bio/ecological parameters, to be filled with sampled or user-specified values.\n\nAny parameter added to the params DataFrame defined here will automatically be made available to the ADRIA model.\n\nNotes: Values for the historical, temporal patterns of degree heating weeks between bleaching years come from [1].\n\nReturns\n\nparams : NamedTuple[taxanames, paramnames, params], taxa names, parameter          names, and parameter values for each coral taxa, group and size class\n\nReferences\n\nLough, J. M., Anderson, K. D., & Hughes, T. P. (2018).  Increasing thermal stress for tropical coral reefs: 1871-2017.  Scientific Reports, 8(1), 6079.  https://doi.org/10.1038/s41598-018-24530-9\nHall, V.R. & Hughes, T.P. 1996. Reproductive strategies of modular organisms:   comparative studies of reef-building corals. Ecology, 77: 950 - 963. https://dx.doi.org/10.2307/2265514\nBozec, Y.-M., Rowell, D., Harrison, L., Gaskell, J., Hock, K.,  Callaghan, D., Gorton, R., Kovacs, E. M., Lyons, M., Mumby, P.,  & Roelfsema, C. (2021). Baseline mapping to support reef restoration and   resilience-based management in the Whitsundays. https://doi.org/10.13140/RG.2.2.26976.20482\nBozec, Y.-M., Hock, K., Mason, R. A. B., Baird, M. E., Castro-Sanguino, C.,  Condie, S. A., Puotinen, M., Thompson, A., & Mumby, P. J. (2022). Cumulative impacts across Australia's Great Barrier Reef: A mechanistic evaluation. Ecological Monographs, 92(1), e01494. https://doi.org/10.1002/ecm.1494\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.create_BI_format_file-Tuple{ADRIA.ResultSet, String}","page":"ADRIA API","title":"ADRIA.create_BI_format_file","text":"create_BI_format_file(rs, file_loc)\n\nCreates a tabular csv files from ADRIA ResultSet, suitable for processing in PowerBI etc. Saves as csv at file_loc.\n\nArguments:\n\nrs::ResultSet: ADRIA result set\nfile_loc::String: directory to save the csv file in\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.create_coral_struct","page":"ADRIA API","title":"ADRIA.create_coral_struct","text":"create_coral_struct(bounds=(0.9, 1.1))\n\nGenerates Coral struct using the default parameter spec.\n\nExample\n\n# Define coral struct with auto-generated parameter ranges\n# (default in ADRIA is ± 10%, triangular distribution with peak at 0.5)\ncreate_coral_struct()\ncoral = Coral()\n\n# Recreate coral spec ± 50% from nominal values\ncreate_coral_struct((0.5, 1.5))\ncoral = Coral()\n\n\n\n\n\n","category":"function"},{"location":"API/#ADRIA.create_decision_matrix-NTuple{12, Any}","page":"ADRIA API","title":"ADRIA.create_decision_matrix","text":"create_decision_matrix(site_ids, in_conn, out_conn, sum_cover, max_cover, area, wave_stress, heat_stress, predec, risk_tol)\n\nCreates criteria matrix A, where each column is a selection criterium and each row is a site. Sites are then filtered based on heat and wave stress risk.\n\nWhere no sites are filtered, size of A = n_sites  7 criteria.\n\nColumns indicate:\n\nSite ID\nIncoming Node Connectivity Centrality\nOutgoing Node Connectivity Centrality\nWave stress\nHeat stress\nPriority Predecessors\nAvailable Area (relative to max cover)\n\nArguments\n\nsite_ids : vector of site ids\nin_conn : site incoming centrality (relative strength of connectivity) (0 <= c <= 1.0)\nout_conn : site outgoing centrality (relative strength of connectivity) (0 <= c <= 1.0)\nsumcover : vector, sum of coral cover (across species) for each site (i.e., [x₁, x₂, ..., xₙ] where x{1:n} <= 1.0)\nmax_cover : maximum possible proportional coral cover (k) for each site, relative to total site area (k <= 1.0)\narea : total absolute area (in m²) for each site\nwave_stress : Probability of wave damage\nheat_stress : Probability of site being affected by heat stress\npredec : list of priority predecessors (sites strongly connected to priority sites)\nrisk_tol : tolerance for wave and heat risk (∈ [0,1]). Sites with heat or wave risk> risktol are filtered out.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.create_seed_matrix-NTuple{9, Any}","page":"ADRIA API","title":"ADRIA.create_seed_matrix","text":"create_seed_matrix(A, min_area, inconn_seed, outconn_seed, waves, heat, predec, low_cover)\n\nCreate seeding specific decision matrix from criteria matrix. The weight criteria and filter.\n\nArguments\n\nA : Criteria matrix\nmin_area : Minimum available area for a site to be considered\ninconn_seed : Seed connectivity weight for seeding\noutconn_seed : Seed connectivity weight for seeding\nwaves : Wave stress weight\nheat : Heat stress weight\npredec : Priority predecessor weight\nlow_cover : Weighting for low coral cover (coral real estate), when seeding\n\nReturns\n\nTuple (SE, wse)\n\nSE : Matrix of shape [n sites considered, 7]\nSite index ID\nIncoming Centrality\nOutgoing Centrality\nWave risk (higher values = less risk)\nDamage risk (higher values = less risk)\nPriority predecessors relating to coral real estate relative to max capacity\nAvailable space\nwse : 5-element vector of criteria weights\nincoming connectivity\noutgoing connectivity\nwave\nheat\nseed predecessors (weights importance of sites highly connected to priority sites for seeding)\nlow cover (weights importance of sites with low cover/high available real estate to plant corals)\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.create_shade_matrix-NTuple{8, Any}","page":"ADRIA API","title":"ADRIA.create_shade_matrix","text":"create_shade_matrix(A, wtconshade, wtwaves, wtheat, wtpredecshade, wthicover)\n\nCreate shading specific decision matrix and apply weightings.\n\nArguments\n\nA : Criteria  matrix\nwtconshade : Shading connectivity weight\nwtwaves : Wave stress weight\nwtheat : Heat stress weight\nwtpredecshade : Priority predecessor weight for shading\nwthicover : Weighting for high coral cover when shading\n\nReturns\n\nTuple (SH, wsh)\n\nSH : Matrix of shape [n sites considered, 7]\nSite index ID\nIncoming Centrality\nOutgoing Centrality\nWave risk (higher values = less risk)\nDamage risk (higher values = less risk)\nPriority predecessors relating to coral real estate relative to max capacity\nAvailable space\nwsh : 5-element vector of criteria weights\nshade connectivity\nwave\nheat\nshade predecessors (weights importance of sites highly connected to priority sites for shading)\nhigh cover (weights importance of sites with high cover of coral to shade)\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.dMCDA-Tuple{ADRIA.DMCDA_vars, Int64, Bool, Bool, AbstractArray{Int64}, AbstractArray{Int64}, Matrix{Int64}}","page":"ADRIA API","title":"ADRIA.dMCDA","text":"dMCDA(d_vars::DMCDA_vars, alg_ind::Int64, log_seed::Bool, log_shade::Bool, prefseedsites::AbstractArray{Int}, prefshadesites::AbstractArray{Int}, rankingsin::Matrix{Int64})\n\nArguments\n\ndvars : DMCDAvars type struct containing weightings and criteria values for site selection.\nalg_ind : integer indicating MCDA aggregation method to use (0: none, 1: order ranking, 2:topsis, 3: vikor)\nlog_seed : boolean ideicating whether seeding sites are being re-assesed at current time\nlog_shade : boolean ideicating whether shading/fogging sites are being re-assesed at current time\nprefshadesites : previous time step's selection of sites for shading\nprefseedsites : previous time step's selection of sites for seeding\nrankingsin : storage for site rankings\n\nReturns\n\nTuple :     - prefseedsites : nsiteint highest ranked seeding sites     - prefshadesites : nsiteint highest ranked shading/fogging sites     - number of seed sites : nprefseedsites     - nprefshadesites : number of shade sites     - rankings : nsitesx3 matrix holding [siteid, seedingrank, shading_rank],         0 indicates sites that were not considered\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.distance_sorting-Tuple{AbstractArray{Int64}, Matrix{Union{Float64, Int64}}, Array{Float64}, Float64, Int64, Matrix{Int64}, Int64}","page":"ADRIA API","title":"ADRIA.distance_sorting","text":"distance_sorting(pref_sites::AbstractArray{Int}, site_order::AbstractVector, dist::Array{Float64}, dist_thresh::Float64, top_n::Int64)::AbstractArray{Int}\n\nFind selected sites with distances between each other < median distance-distthresh*(median distance). Replaces these sites with sites in the topn ranks if the distance between these sites is greater.\n\nArguments\n\npref_sites : original n highest ranked sites selected for seeding or shading.\nsite_order : current order of ranked sites in terms of numerical site ID.\ndist : Matrix of unique distances between sites.\nmin_dist : minimum distance between sites for selected sites.\ntop_n : number of top ranked sites to re-select from.\n\nReturns\n\nprefsites : new set of selected sites for seeding or shading.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.distribute_seeded_corals-Tuple{Vector{Float64}, Vector{Int64}, Vector{Float64}, NamedTuple{(:TA, :CA), Tuple{Float64, Float64}}}","page":"ADRIA API","title":"ADRIA.distribute_seeded_corals","text":"distribute_seeded_corals(total_site_area::Vector{Float64},\n    prefseedsites::Vector{Int64}, available_space::Vector{Float64},\n    seeded_area::NamedTuple{(:TA, :CA),Tuple{Float64,Float64}})::NamedTuple{(:TA, :CA),Tuple{Vector{Float64},Vector{Float64}}}\n\nCalculate proportion of Tabular Acropora (TA) and Corymbose Acropora (CA) to be seeded at each of the nsiteint seeding sites selected. Distributes seeded corals according to current available space at each selected site.\n\nArguments\n\ntotalsitearea : nsites*1, total area at each site in m^2.\nprefseedsites : nsiteint*1, indices for the selected seeding sites.\navailable_space : nsites*1, current available space at each site in m^2.\nseeded_area : area (in m²) of each coral type to be seeded with\nTA : colony area of a TA.\nCA : colony area of a CA.\n\nReturns\n\nscaledseed : NamedTuple (TA = scaledseedTA, CA = scaledseed_CA), where:     - TA : nsiteint elements, proportions of TA coral to seed at prefseedsites     - CA : nsiteint elements, proportions of CA coral to seed at prefseedsites.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.env_stats-Tuple{ADRIA.ResultSet, String, String}","page":"ADRIA API","title":"ADRIA.env_stats","text":"env_stats(rs::ResultSet, s_name::String, rcp::String)\nenv_stats(rs::ResultSet, s_name::String, rcp::String, member::Int)\nenv_stats(rs::ResultSet, s_name::String, stat::String, rcp::String, member::Int)\n\nExtract statistics for a given environmental layer (\"DHW\" or \"wave\")\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.fecundity_scope!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractArray{Float64}, AbstractMatrix{Float64}, AbstractArray{Float64}}","page":"ADRIA API","title":"ADRIA.fecundity_scope!","text":"fecundity_scope!(fec_groups::Array{Float64, 2}, fec_all::Array{Float64, 2}, fec_params::Array{Float64},\n                 Y_pstep::Array{Float64, 2}, k_area::Array{Float64})::Nothing\n\nThe scope that different coral groups and size classes have for producing larvae without consideration of environment.\n\nCoral fecundity per coral area of the different size classes. When multiplied by the relative cover of each size class within taxa, this produces an estimate of the relative fecundity of each coral group and size. Total relative fecundity of a group is then calculated as the sum of fecundities across size classes.\n\nArguments\n\nfecgroups : Matrix[nclasses, n_sites], memory cache to place results into\nfecall : Matrix[ntaxa, n_sites], temporary cache to place intermediate fecundity values into\nfec_params : Vector, coral fecundity parameters (in per m²) for each species/size class\nYpstep : Matrix[ntaxa, n_sites], of coral cover values for the previous time step\nsitearea : Vector[nsites], total site area in m²\n\nReturns\n\nMatrix[nclasses, nsites] : fecundity per m² of coral\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.get_DHW_data-Tuple{Domain, String}","page":"ADRIA API","title":"ADRIA.get_DHW_data","text":"Get the path to the DHW data associated with the domain.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.get_wave_data-Tuple{Domain, String}","page":"ADRIA API","title":"ADRIA.get_wave_data","text":"Get the path to the wave data associated with the domain.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.growthODE-Tuple{Matrix{Float64}, Matrix{Float64}, NamedTuple, Real}","page":"ADRIA API","title":"ADRIA.growthODE","text":"growthODE(du, X, p, _)\n\nBase coral growth function.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.growthODE_expanded-Tuple{Matrix{Float64}, Matrix{Float64}, NamedTuple, Real}","page":"ADRIA API","title":"ADRIA.growthODE_expanded","text":"Not intended for use in production.\n\nThe ODE defined here is identical to growth.jl::growthODE() in function. The terms are expanded out to cover each coral taxa/size class.\n\nArguments\n\ndu : matrix holding derivatives X : Current coral cover, relative to k p : additional parameters t : time, unused, so marking with _\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.has_setup-Tuple{}","page":"ADRIA API","title":"ADRIA.has_setup","text":"Check to ensure setup has been run.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.human_readable_name","page":"ADRIA API","title":"ADRIA.human_readable_name","text":"human_readable_name(names::Array{String}, title_case::Bool)\n\nMake presentable parameter labels. Returns a copy of original array so input is not modified.\n\nArguments\n\nnames : parameter names to convert\ntitle_case : boolean, whether to convert to Title Case or not.\n\nReturns\n\nconverted_names : array[str], of cleaned parameter names\n\n\n\n\n\n","category":"function"},{"location":"API/#ADRIA.load_covers-Tuple{String, String, DataFrames.DataFrame}","page":"ADRIA API","title":"ADRIA.load_covers","text":"load_covers(data_fn::String, attr::String, site_data::DataFrame)::NamedArray\n\nLoad initial coral cover data from netCDF.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.load_domain-Tuple{String, String}","page":"ADRIA API","title":"ADRIA.load_domain","text":"load_domain(path::String, rcp::Int64)\nload_domain(path::String, rcp::String)\nload_domain(path::String)\n\nLoad domain specification from data package.\n\nArguments\n\npath : location of data package\nrcp : RCP scenario to run. If none provided, no data path is set.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.load_env_data-Tuple{String, String, DataFrames.DataFrame}","page":"ADRIA API","title":"ADRIA.load_env_data","text":"load_env_data(data_fn::String, attr::String, site_data::DataFrame)::NamedArray\n\nLoad environmental data layers (DHW, Wave) from netCDF.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.load_nc_data-Tuple{String, String, DataFrames.DataFrame}","page":"ADRIA API","title":"ADRIA.load_nc_data","text":"load_nc_data(data_fn::String, attr::String, n_sites::Int)::NamedArray\n\nLoad netCDF data as a NamedArray.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.load_results-Tuple{String}","page":"ADRIA API","title":"ADRIA.load_results","text":"load_results(result_loc::String)::ResultSet\nload_results(domain::Domain)::ResultSet\n\nCreate interface to a given Zarr result set.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.load_scenarios-Union{Tuple{D}, Tuple{D, String}} where D","page":"ADRIA API","title":"ADRIA.load_scenarios","text":"load_scenarios(domain::Domain, filepath::String)::DataFrame\n\nLoad and pre-process scenario values. Parameters intended to be of Integer type or casted as such.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.map_to_discrete!-Tuple{DataFrames.DataFrame, Union{Tuple, AbstractArray}}","page":"ADRIA API","title":"ADRIA.map_to_discrete!","text":"map_to_discrete!(df::DataFrame, u::AbstractArray)::Nothing\n\nUpdate a dataframe of parameters. Length of u is expected to match number of columns in df.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.map_to_discrete-Tuple{Number, Int64}","page":"ADRIA API","title":"ADRIA.map_to_discrete","text":"map_to_discrete(v::Number, u::Int)::Int\n\nFor integer/categorical parameters, take floor of v, capping to u - 1\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.max_maindiag-Tuple{AbstractArray}","page":"ADRIA API","title":"ADRIA.max_maindiag","text":"max_maindiag(A::AbstractArray)\n\nGet the maximum diagonal values in matrix A.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.max_offdiag-Tuple{AbstractArray}","page":"ADRIA API","title":"ADRIA.max_offdiag","text":"max_offdiag(A::AbstractArray)\n\nGet the maximum off-diagonal values in matrix A.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.mcda_normalize-Tuple{Matrix}","page":"ADRIA API","title":"ADRIA.mcda_normalize","text":"mcda_normalize(x::Matrix)::Matrix\n\nNormalize a Matrix (SE/SH) for MCDA.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.mcda_normalize-Tuple{Vector}","page":"ADRIA API","title":"ADRIA.mcda_normalize","text":"mcda_normalize(x::Vector)::Vector\n\nNormalize a Vector (wse/wsh) for MCDA.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.model_spec-Tuple{ADRIA.ResultSet}","page":"ADRIA API","title":"ADRIA.model_spec","text":"model_spec(rs::ResultSet)::DataFrame\n\nExtract model specification from Result Set.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.model_spec-Tuple{Domain}","page":"ADRIA API","title":"ADRIA.model_spec","text":"model_spec(d::Domain)::DataFrame\nmodel_spec(d::Domain, filepath::String)::Nothing\n\nGet model specification as DataFrame with lower and upper bounds. If a filepath is provided, writes the specification out to file with ADRIA metadata.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.offdiag-Tuple{AbstractArray}","page":"ADRIA API","title":"ADRIA.offdiag","text":"offdiag(A::AbstractArray)\n\nGet off-diagonal values of matrix A.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.order_ranking-Tuple{Matrix{Float64}}","page":"ADRIA API","title":"ADRIA.order_ranking","text":"order_ranking(S::Array{Float64, 2})\n\nUses simple summation as aggregation method for decision criteria. Then orders sites from highest aggregate score to lowest.\n\nArguments\n\nS : Decision matrix (seeding or shading)\n\nReturns\n\ns_order : nsites × 3 matrix with columns\nsite ids\ncalculated site rank score (higher values = higher ranked)\nsite order id\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.param_table-Tuple{Domain}","page":"ADRIA API","title":"ADRIA.param_table","text":"param_table(d::Domain)::DataFrame\n\nGet model fieldnames and their parameter values.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.process_inputs!-Union{Tuple{D}, Tuple{D, DataFrames.DataFrame}} where D","page":"ADRIA API","title":"ADRIA.process_inputs!","text":"process_inputs!(d::D, df::DataFrame)::Nothing where {D}\n\nMap sampled values in df back to discrete bounds for parameters indicated to be of integer type in the Domain spec.\n\nArguments\n\nd : Domain type\ndf : DataFrame\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.proportional_adjustment!-Tuple{AbstractArray{<:Real}, AbstractArray{<:Real}, AbstractArray{<:Real}}","page":"ADRIA API","title":"ADRIA.proportional_adjustment!","text":"proportional_adjustment!(covers::AbstractArray{<:Real}, cover_tmp::AbstractArray{<:Real}, max_cover::AbstractArray{<:Real})\n\nHelper method to proportionally adjust coral cover. Modifies arrays in-place.\n\nArguments\n\ncovers : Coral cover result set\ncover_tmp : Temporary cache matrix used to hold sum over species. Avoids memory allocations\nmax_cover : Maximum possible coral cover for each site\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.rank_sites!-NTuple{6, Any}","page":"ADRIA API","title":"ADRIA.rank_sites!","text":"rank_sites!(S, weights, rankings, nsiteint, rank_col)\nrank_seed_sites!(S, weights, rankings, nsiteint)\nrank_shade_sites!(S, weights, rankings, nsiteint)\n\nArguments\n\nS : Matrix, Site preference values\nweights : weights to apply\nrankings : vector of site ranks to update\nnsiteint : number of sites to select for interventions\nrank_col : column to fill with rankings (2 for seed, 3 for shade)\n\nReturns\n\nprefsites : sites in order of their rankings\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.recruitment-Union{Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{<:Real}, Matrix{<:Real}}} where {T, S}","page":"ADRIA API","title":"ADRIA.recruitment","text":"recruitment(larval_pool, A::Matrix{<:Real}; α=2.5, β=5000.0)\n\nArguments\n\nlarval_pool : Available larval pool\nA : Available space (0 - 1) relative to maximum area covered by     cropped algal turf, i.e., the substratum that is suitable      for coral recruitment\nα : Maximum achievable density (settlers/m²) for a 100% free space\nβ : Stock of larvae required to produce 50% of the maximum settlement\n\nReturns\n\nTotal coral recruitment for each coral taxa and site based on a Poisson distribution.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.recruitment_rate-Tuple{AbstractMatrix{<:Real}, AbstractArray{<:Real}}","page":"ADRIA API","title":"ADRIA.recruitment_rate","text":"recruitment_rate(larval_pool, α=2.5, β=5000.0)\n\nArguments\n\nlarval_pool : Available larval pool\nA : Proportion of available area\nα : Maximum achievable density (settlers/m²) for a 100% free space\nβ : Stock of larvae required to produce 50% of the maximum settlement\n\nReturns\n\nλ, coral recruitment for each coral taxa based on a Poisson distribution.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.relative_leftover_space-Tuple{Domain, Matrix{Float64}}","page":"ADRIA API","title":"ADRIA.relative_leftover_space","text":"relative_leftover_space(domain::Domain)::Vector{Float64}\nrelative_leftover_space(site_k::Matrix{Float64}, site_coral_cover::Matrix{Float64})::Matrix{Float64}\n\nGet proportion of leftover space, given site_k and proportional cover on each site, summed over species.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.result_location-Tuple{Domain}","page":"ADRIA API","title":"ADRIA.result_location","text":"result_location(d::Domain)::String\n\nGenerate path to the data store of results for the given Domain.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.run_model-Tuple{Domain, Union{AbstractVector, DataFrames.DataFrameRow}, DataFrames.DataFrame, NamedTuple}","page":"ADRIA API","title":"ADRIA.run_model","text":"run_model(domain::Domain, param_set::Union{NamedTuple,DataFrameRow}, corals::DataFrame, cache::NamedTuple)::NamedTuple\n\nCore scenario running function.\n\nNotes\n\nOnly the mean site rankings are kept\n\nReturns\n\nNamedTuple of collated results\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.run_scenario-Tuple{Int64, Union{AbstractVector, DataFrames.DataFrameRow}, Domain, NamedTuple, NamedTuple}","page":"ADRIA API","title":"ADRIA.run_scenario","text":"run_scenario(idx, param_set::Union{AbstractVector, DataFrameRow}, domain::Domain, data_store::NamedTuple, cache::NamedTuple)::NamedTuple\nrun_scenario(idx, param_set::Union{AbstractVector, DataFrameRow}, domain::Domain, data_store::NamedTuple)::NamedTuple\nrun_scenario(param_set::Union{AbstractVector, DataFrameRow}, domain::Domain, cache::NamedTuple)::NamedTuple\nrun_scenario(param_set::NamedTuple, domain::Domain)::NamedTuple\n\nRun individual scenarios for a given domain, saving results to a Zarr data store. Results are stored in Zarr format at a pre-configured location. Sets up a new cache if not provided.\n\nNotes\n\nLogs of site ranks only store the mean site rankings over all environmental scenarios. This is to reduce the volume of data stored.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.run_scenarios-Tuple{DataFrames.DataFrame, Domain}","page":"ADRIA API","title":"ADRIA.run_scenarios","text":"run_scenarios(param_df::DataFrame, domain::Domain; remove_workers=true)\nrun_scenarios(param_df::DataFrame, domain::Domain, rcp::String; remove_workers=true)\nrun_scenarios(param_df::DataFrame, domain::Domain, rcp::Array{String}; remove_workers=true)\n\nRun scenarios defined by the parameter table storing results to disk. Scenarios are run in parallel where the number of scenarios > 256.\n\nNotes\n\nReturned domain holds scenario invoke time used as unique result set identifier.\nIf multiple RCPs are specified, this method will temporarily use double the disk space to consolidate results into a single ResultSet.\n\nExamples\n\n...\njulia> rs_45 = ADRIA.run_scenarios(p_df, dom, \"45\")\njulia> rs_45_60 = ADRIA.run_scenarios(p_df, dom, [\"45\", \"60\"])\njulia> rs_all = ADRIA.run_scenarios(p_df, dom)\n\nArguments\n\nparam_df : DataFrame of scenarios to run\ndomain : Domain, to run scenarios with\nrcp : ID of RCP(s) to run scenarios under.\nremove_workers : if running in parallel, removes workers after completion\n\nReturns\n\nResultSet\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.sample_cf","page":"ADRIA API","title":"ADRIA.sample_cf","text":"sample_cf(d::Domain, n::Int, sampler=SobolSample())::DataFrame\n\nGenerate only counterfactual scenarios using any sampler from QuasiMonteCarlo.jl\n\n\n\n\n\n","category":"function"},{"location":"API/#ADRIA.sample_guided","page":"ADRIA API","title":"ADRIA.sample_guided","text":"sample_guided(d::Domain, n::Int, sampler=SobolSample())::DataFrame\n\nGenerate only guided scenarios using any sampler from QuasiMonteCarlo.jl\n\n\n\n\n\n","category":"function"},{"location":"API/#ADRIA.scenario_attributes-NTuple{10, Any}","page":"ADRIA API","title":"ADRIA.scenario_attributes","text":"scenario_attributes(name, RCP, input_cols, invoke_time, env_layer, sim_constants, unique_sites, area, k)\nscenario_attributes(domain::Domain, param_df::DataFrame)\n\nGenerate dictionary of scenario attributes.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.select-Tuple{ADRIA.ResultSet, String}","page":"ADRIA API","title":"ADRIA.select","text":"select(r::ResultSet, op::String)\n\nHacky scenario filtering - to be replaced with more robust approach.\n\nOnly supports filtering by single attribute. Should be expanded to support filtering metric results too.\n\nExamples\n\nselect(result, \"guided .> 0.0\")\n\n# Above expands to:\n# result.inputs.guided .> 0.0\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.set-Tuple{ModelParameters.Param, Number}","page":"ADRIA API","title":"ADRIA.set","text":"Set a model parameter value directly.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.settler_cover-Union{Tuple{V}, Tuple{T}, Tuple{T, T, T, Matrix{Float64}, V, V, V}} where {T<:(AbstractMatrix{<:Real}), V<:Vector{Float64}}","page":"ADRIA API","title":"ADRIA.settler_cover","text":"settler_cover(fec_scope, sf, TP_data, leftover_space, α, β, basal_area_per_settler)\n\nArguments\n\nfec_scope : fecundity scope\nsf : stressed fecundity\nTP_data : Transition probability\nleftoverspace : difference between sites' maximum carrying capacity and current coral cover (k - Cs)\nα : max number of settlers / m²\nβ : larvae / m² required to produce 50% of maximum settlement (default: 5000.0)\nbasalareaper_settler : area taken up by a single settler\n\nReturns\n\nArea covered by recruited larvae (in m²)\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.settler_density-Tuple{Any, Any, Any}","page":"ADRIA API","title":"ADRIA.settler_density","text":"settler_density(α, β, L)\n\nNote for β: \"For corals, the actual number of 6-month old recruits for each coral group     is generated [...] following a Poisson distribution with recruitment event rate λ.\n\nArguments\n\nα : Maximum achievable density (settlers/m²) for a 100% free space (set to 2.5 in [1] for Corymbose)\nβ : Stock of larvae required to produce one-half the maximum settlement (larvae/m²),       i.e., α/2(m²), set to 5000 in [1].\nL : Available larval pool\n\nReturns\n\nSettler density (settlers / m²)\n\nReferences\n\nBozec, Y.-M., Hock, K., Mason, R. A. B., Baird, M. E.,   Castro-Sanguino, C., Condie, S. A., Puotinen, M.,   Thompson, A., & Mumby, P. J. (2022). Cumulative impacts across Australia's Great Barrier Reef:   A mechanistic evaluation. Ecological Monographs, 92(1), e01494. https://doi.org/10.1002/ecm.1494\n\nExamples\n\nsettler_density(2.5, 5000.0, L)\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.setup_cache-Tuple{Domain}","page":"ADRIA API","title":"ADRIA.setup_cache","text":"setup_cache(domain::Domain)::NamedTuple\n\nEstablish tuple of matrices/vectors for use as reusable data stores to avoid repeated memory allocations.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.setup_result_store!-Tuple{Domain, DataFrames.DataFrame}","page":"ADRIA API","title":"ADRIA.setup_result_store!","text":"setup_result_store!(domain::Domain, param_df::DataFrame)\n\nSets up an on-disk result store.\n\nStructure of Store\n\n├───logs\n│   ├───fog\n│   ├───rankings\n│   ├───seed\n│   └───shade\n├───results\n│   ├───relative_cover\n│   ├───relative_shelter_volume\n│   └───absolute_shelter_volume\n├───site_data\n├───model_spec\n└───inputs\n\ninputs : includes domain specification metadata including what connectivity/DHW/wave data was used.\nsite_data : contains a copy of the spatial domain data (as geopackage).\nmodel_spec : contains a copy of the ADRIA model specification (as CSV).\n\nNotes\n\ndomain is replaced with an identical copy with an updated scenario invoke time.\n-9999.0 is used as an arbitrary fill value.\n\nArguments\n\ndomain : ADRIA scenario domain\nparam_df : ADRIA scenario specification\n\nReturns\n\ndomain, (relativecover, relativesheltervolume, absolutesheltervolume, siteranks, seedlog, foglog, shade_log)\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.site_area-Tuple{Domain}","page":"ADRIA API","title":"ADRIA.site_area","text":"site_area(domain::Domain)::Vector{Float64}\n\nGet site area for the given domain.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.site_connectivity-Tuple{String, Vector{String}}","page":"ADRIA API","title":"ADRIA.site_connectivity","text":"site_connectivity(file_loc, site_order; con_cutoff=0.02, agg_func=mean, swap=false)::NamedTuple\n\nCreate transitional probability matrix indicating connectivity between sites, level of centrality, and the strongest predecessor for each site.\n\nNOTE: Transposes transitional probability matrix if swap == true       If multiple files are read in, this assumes all file rows/cols       follow the same order as the first file read in.\n\nExamples\n\n    site_connectivity(\"MooreTPmean.csv\", site_order)\n    site_connectivity(\"MooreTPmean.csv\", site_order; con_cutoff=0.02, agg_func=mean, swap=true)\n\nArguments\n\nfile_loc : str, path to data file (or datasets) to load.              If a folder, searches subfolders as well.\nunique_ids : Vector, of unique site ids in their expected order\nsiteorder : Vector, of indices mapping duplicate connids to their unique ID positions\ncon_cutoff : float, percent thresholds of max for weak connections in               network (defined by user or defaults in simConstants)\naggfunc : functionhandle, defaults to mean.\nswap : boolean, whether to transpose data.\n\nReturns\n\nNamedTuple:\n\nTP_data : Matrix, containing the transition probability for all sites\ntruncated : ID of sites removed\nsite_ids : ID of sites kept\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.site_k-Tuple{Domain}","page":"ADRIA API","title":"ADRIA.site_k","text":"site_k(domain::Domain)::Vector{Float64}\n\nGet maximum coral cover area as a proportion of site area.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.site_k_area-Tuple{Domain}","page":"ADRIA API","title":"ADRIA.site_k_area","text":"site_k_area(domain::Domain)::Vector{Float64}\n\nGet maximum coral cover area for the given domain in absolute area.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.site_selection-Tuple{Domain, DataFrames.DataFrame, Float64, Int64, Int64, Int64}","page":"ADRIA API","title":"ADRIA.site_selection","text":"site_selection(domain::Domain, criteria::DataFrame, area_to_seed::Float64, ts::Int, n_reps::Int, alg_ind::Int)\n\nReturns\n\nMatrix : nreps * sites * 3 last dimension indicates: siteid, seeding rank, shading rank\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.slow_ODE-NTuple{4, Any}","page":"ADRIA API","title":"ADRIA.slow_ODE","text":"slow_ODE(Y, X, p, t)\n\nSlow version of the growth model, ported directly from MATLAB.\n\nProportions of corals within a size class transitioning to the next size class up (r) is based on the assumption that colony sizes within each size bin are evenly distributed within bins. Transitions are then a simple ratio of the change in colony size to the width of the bin. See coralParms for further explanation of these coral metrics.\n\nNote that recruitment pertains to coral groups (n = 6) and represents the contribution to the cover of the smallest size class within each group.  While growth and mortality metrics pertain to groups (6) as well as size classes (6) across all sites (total of 36 by nsites), recruitment is a 6 by nsites array.\n\nReshape flattened input from ODE back to expected matrix shape Dims: (coral species, sites)\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.store_env_summary-Tuple{AbstractArray, String, String, String, Zarr.Compressor}","page":"ADRIA API","title":"ADRIA.store_env_summary","text":"store_env_summary(data_cube::AbstractArray, type::String, file_loc::String, compressor::Zarr.Compressor)\n\nRetrieve summary statistics matrices from DataFrames of dhws and waves. Produce summary statistics (mean/std) for given data cube saved to a Zarr data store.\n\nArguments\n\ndata_cube : data to summarize\ntype : dimension identifier to use\nfile_loc : path for Zarr data store\n\nReturns\n\nZarr data store holding a 2*N matrix.\n\nFirst row is mean over time Second row is the std over time N is the number of dhw/wave scenarios.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.store_location-Tuple{ADRIA.ResultSet}","page":"ADRIA API","title":"ADRIA.store_location","text":"store_location(r::ResultSet)::String\n\nGet location of result set.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.store_name-Tuple{ADRIA.ResultSet}","page":"ADRIA API","title":"ADRIA.store_name","text":"store_name(r::ResultSet)::String\n\nGet name of result set.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.stressed_fecundity-Tuple{Int64, Vector{Float64}, Float64, Vector{Float64}, Float64, Float64, Float64, Int64}","page":"ADRIA API","title":"ADRIA.stressed_fecundity","text":"stressed_fecundity(tstep, a_adapt, n_adapt, stresspast, LPdhwcoeff, DHWmaxtot, LPDprm2, n_groups)\n\nEstimate how scope for larval production by each coral type changes as a function of last year's heat stress. The function is theoretical and is not yet verified by data.\n\nStressed Fecundity (sf) is based on the proportion of baseline fecundity that is unaffected by heat stress in the previous year - e.g., a value of 0.9 inside sf(i, j) indicates that species i at site j can only produce 90% of its usual larval output.\n\nArguments\n\ntstep : Current time step\na_adapt : DHW reduction of enhanced corals\nn_adapt : DHWs reduction (linearly scales with tstep)\nstresspast : DHW at previous time step for each site\nLPdhwcoeff : \nDHWmaxtot : Maximum DHW\nLPDprm2 : Larval production parameter 2\nn_groups : Number of groups\n\nReturns\n\nsf : Array of values ∈ [0,1] indicating reduced fecundity from a baseline.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.summarize_env_data-Tuple{AbstractArray}","page":"ADRIA API","title":"ADRIA.summarize_env_data","text":"summarize_env_data(data_cube::AbstractArray)\n\nSummarize environmental data layers (mean and standard deviation).\n\nReturns\n\nMatrix{Float64, 2}, of mean and standard deviation for each environmental scenario.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.switch_RCPs!-Tuple{Domain, String}","page":"ADRIA API","title":"ADRIA.switch_RCPs!","text":"switch_RCPs!(d::Domain, RCP::String)::Domain\n\nSwitch environmental datasets to represent the given RCP.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.timesteps-Tuple{ADRIA.ResultSet}","page":"ADRIA API","title":"ADRIA.timesteps","text":"timesteps(rs::ResultSet)\n\nRetrieve the time steps represented in the result set.\n\nArguments\n\nrs : ResultSet\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.timesteps-Tuple{Domain}","page":"ADRIA API","title":"ADRIA.timesteps","text":"Extract the time steps represented in the data package.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.to_spec-Tuple{ADRIA.Coral}","page":"ADRIA API","title":"ADRIA.to_spec","text":"to_spec(m::Model)::DataFrame\n\nConvert Coral Model specification to a coral spec DataFrame\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.to_spec-Tuple{DataFrames.DataFrame}","page":"ADRIA API","title":"ADRIA.to_spec","text":"to_spec(coral_df::DataFrame)::DataFrame\n\nConvert dataframe of model parameters to a coral spec.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.topsis-Tuple{Matrix{Float64}}","page":"ADRIA API","title":"ADRIA.topsis","text":"topsis(S::Array{Float64, 2})\n\nCalculates ranks using the aggregation method of the TOPSIS MCDA algorithm. Rank for a particular site is calculated as a ratio\n\nC = S_n/(S_p + S_n)\n\nSn = √{∑(criteria .- NIS)²}     is the squareroot of the summed differences between the criteria for a site and the     Negative Ideal Solution (NIS), or worst performing site in each criteria. Sp  = √{∑(criteria .- NIS)²}     is the squareroot of the summed differences between the criteria for a site and the     Positive Ideal Solution (PIS), or best performing site in each criteria.\n\nDetails of this aggregation method in, for example [1].\n\nReferences\n\nOpricovic, Serafim & Tzeng, Gwo-Hshiung. (2004) European Journal of Operational Research.  Vol. 156. pp. 445.  https://doi.org/10.1016/S0377-2217(03)00020-1.\n\nArguments\n\nS : Decision matrix (seeding or shading)\n\nReturns\n\ns_order :\nsite ids\ncalculated site rank score (higher values = higher ranked)\nsite order id\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.unguided_site_selection-NTuple{7, Any}","page":"ADRIA API","title":"ADRIA.unguided_site_selection","text":"unguided_site_selection(prefseedsites, prefshadesites, seed_years, shade_years, nsiteint, max_cover)\n\nRandomly select seed/shade site locations for the given year, constraining to sites with max. carrying capacity > 0. Here, max_cover represents the max. carrying capacity for each site (the k value).\n\nArguments\n\nprefseedsites : Previously selected sites\nseed_years : bool, indicating whether to seed this year or not\nshade_years : bool, indicating whether to shade this year or not\nnsiteint : int, number of sites to intervene on\navailable_space : vector/matrix : space available at each site (k value)\ndepth : vector of site ids found to be within desired depth range\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.update_params!-Tuple{Domain, Union{AbstractVector, DataFrames.DataFrameRow}}","page":"ADRIA API","title":"ADRIA.update_params!","text":"update_params!(d::Domain, params::DataFrameRow)\n\nUpdate given domain with new parameter values. Maps sampled continuous values to discrete values for categorical variables.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.vikor-Tuple{Matrix{Float64}}","page":"ADRIA API","title":"ADRIA.vikor","text":"vikor(S; v=0.5)\n\nCalculates ranks using the aggregation method of the VIKOR MCDA algorithm. Rank for a particular site is calculated as a linear combination of ratios, weighted by v:     Q = v(Sr - Sh) / (Ss - Sh) + (1 - v)(R - Rh) / (Rs - Rh)\n\nwhere\n\nSr = ∑(PIS-criteria) for each site, summed over criteria.\nR = max(PIS-criteria) for each site, with the max over criteria.\nS_h = min(∑(PIS-criteria)) over sites, the minimum summed distance from   the positive ideal solution.\nS_s = max(∑(PIS-criteria)) over sites, maximum summed distance from   the positive ideal solution.\nR_h = min(max(PIS-criteria)) over sites, the minimum max distance from   the positive ideal solution.\nR_s = max(max(PIS-criteria)) over sites, the maximum max distance from   the positive ideal solution.\nv = weighting, representing different decision-making strategies,   or level of compromise between utility (overall performance)   and regret (risk of performing very badly in one criteria despite   exceptional performance in others)\nv = 0.5 is consensus\nv < 0.5 is minimal regret\nv > 0.5 is max group utility (majority rules)\n\nDetails of this aggregation method in, for example [1]\n\nReferences\n\nAlidrisi H. (2021) Journal of Risk and Financial Management.  Vol. 14. No. 6. pp. 271.  https://doi.org/10.3390/jrfm14060271\n\nArguments\n\nS : Matrix\nv : Real\n\nReturns\n\ns_order :\nsite ids\ncalculated site rank score (higher values = higher ranked)\nsite order id\n\n\n\n\n\n","category":"method"},{"location":"API/#ModelParameters.update!-Tuple{ModelParameters.Model, Union{Tuple, Array}}","page":"ADRIA API","title":"ModelParameters.update!","text":"Update a given model with new uncertain parameter values.\n\n\n\n\n\n","category":"method"},{"location":"API/#Surrogates.sample","page":"ADRIA API","title":"Surrogates.sample","text":"sample(dom::Domain, n::Int, sampler=SobolSample())::DataFrame\n\nCreate samples using provided sampler, and rescale to distribution defined in the model spec.\n\nNotes:\n\nassumes all parameters are independent.\n\nArguments\n\ndom : Domain\nn : Int\nsampler : Sampling method\n\n\n\n\n\n","category":"function"},{"location":"API/#ADRIA.CoralGrowth","page":"ADRIA API","title":"ADRIA.CoralGrowth","text":"CoralGrowth(n_sites::Integer, n_species::Integer, n_groups::Integer, ode_p::NamedTuple)\n\nCoral growth specification for growth ODE model.\n\n\n\n\n\n","category":"type"},{"location":"API/#ADRIA.CoralGrowth-Tuple{Int64}","page":"ADRIA API","title":"ADRIA.CoralGrowth","text":"CoralGrowth(n_sites)\n\nImplements temporary hardcoded caches for a scenario with 36 'species' (split into 6 groups).\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.Domain","page":"ADRIA API","title":"ADRIA.Domain","text":"Domain{M,I,D,S,V,T,X}\n\nCore ADRIA domain. Represents study area.\n\n\n\n\n\n","category":"type"},{"location":"API/#ADRIA.Domain-Tuple{String, String, ADRIA.EnvLayer, NamedArrays.NamedMatrix, Vector{Float64}, Vector{Float64}, Vector{Int64}, DataFrames.DataFrame, Matrix{Float64}, Float64, String, String, NamedArrays.NamedMatrix, ADRIA.CoralGrowth, Vector{String}, Vector{String}, Union{Matrix, NamedArrays.NamedArray}, Union{Matrix, NamedArrays.NamedArray}}","page":"ADRIA API","title":"ADRIA.Domain","text":"Barrier function to create Domain struct without specifying Intervention/Criteria/Coral/SimConstant parameters.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.Domain-Tuple{String, String, String, Vector, String, String, String, String, String, String, String}","page":"ADRIA API","title":"ADRIA.Domain","text":"Domain(name::String, rcp::String, timeframe::Vector, site_data_fn::String, site_id_col::String, unique_site_id_col::String, init_coral_fn::String,\n       conn_path::String, dhw_fn::String, wave_fn::String)::Domain\n\nConvenience constructor for Domain.\n\nArguments\n\nname : Name of domain\ndpkg_path : location of data package\nrcp : RCP scenario represented\ntimeframe : Time steps represented\nsitedatafn : File name of spatial data used\nsiteidcol : Column holding name of reef the site is associated with (non-unique)\nuniquesiteid_col : Column holding unique site names/ids\ninitcoralfn : Name of file holding initial coral cover values\nconn_path : Path to directory holding connectivity data\ndhw_fn : Filename of DHW data cube in use\nwave_fn : Filename of wave data cube\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.EnvLayer","page":"ADRIA API","title":"ADRIA.EnvLayer","text":"EnvLayer{S, TF}\n\nStore environmental data layers used for scenario\n\n\n\n\n\n","category":"type"},{"location":"API/#ADRIA.SimConstants","page":"ADRIA API","title":"ADRIA.SimConstants","text":"SimConstants\n\nStruct of simulation constants for ADRIA\n\nReferences\n\nLough, J. M., Anderson, K. D., & Hughes, T. P. (2018). Increasing thermal stress for tropical coral reefs: 1871-2017. Scientific Reports, 8(1), 6079. https://doi.org/10.1038/s41598-018-24530-9\nHughes, T. P., Kerry, J. T., Baird, A. H., Connolly, S. R.,   Dietzel, A., Eakin, C. M., Heron, S. F., Hoey, A. S.,   Hoogenboom, M. O., Liu, G., McWilliam, M. J., Pears, R. J.,   Pratchett, M. S., Skirving, W. J., Stella, J. S., & Torda, G. (2018). Global warming transforms coral reef assemblages. Nature, 556(7702), 492-496. https://doi.org/10.1038/s41586-018-0041-2\nBozec, Y.-M., Rowell, D., Harrison, L., Gaskell, J., Hock, K.,   Callaghan, D., Gorton, R., Kovacs, E. M., Lyons, M., Mumby, P.,   & Roelfsema, C. (2021). Baseline mapping to support reef restoration and   resilience-based management in the Whitsundays. https://doi.org/10.13140/RG.2.2.26976.20482\nBozec, Y.-M., Hock, K., Mason, R. A. B., Baird, M. E., Castro-Sanguino, C.,   Condie, S. A., Puotinen, M., Thompson, A., & Mumby, P. J. (2022). Cumulative impacts across Australia's Great Barrier Reef: A mechanistic evaluation.  Ecological Monographs, 92(1), e01494. https://doi.org/10.1002/ecm.1494\n\n\n\n\n\n","category":"type"}]
}
