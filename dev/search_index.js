var documenterSearchIndex = {"docs":
[{"location":"synopsis/#Synopsis","page":"Synopsis","title":"Synopsis","text":"","category":"section"},{"location":"synopsis/","page":"Synopsis","title":"Synopsis","text":"Climate change is transforming coral reefs. Continued climate change has scope to erode reef biodiversity, key ecosystem functions, and the ecosystem services they provide for people. Conventional management strategies remain essential but will not be sufficient on their own to sustain coral reefs in a warming and acidifying ocean. New interventions are increasingly being considered, including assisted gene flow, cooling and shading, and reef structures that provide reef habitats and substrates for enhanced recruitment.","category":"page"},{"location":"synopsis/","page":"Synopsis","title":"Synopsis","text":"Deciding where, when, and how to intervene – if at all - using new reef restoration and adaptation measures is challenging on at least three fronts.","category":"page"},{"location":"synopsis/","page":"Synopsis","title":"Synopsis","text":"are new interventions likely to create more benefits than damage? And if so, whom do they benefit, or pose risks to, and at what spatial and temporal scales?\nwhich interventions, individually and in combination, represent solutions that provide the highest return on investment for reef, people, and industries?\nwhich R&D paths and deployment strategies represent optimal solutions given multiple key objectives, trade-offs, and limited time, resources, and logistical constraints?","category":"page"},{"location":"synopsis/","page":"Synopsis","title":"Synopsis","text":"To help reef modellers, decision-support teams and reef managers address these questions, AIMS has developed the Adaptive, Dynamic Reef Intervention Algorithm (ADRIA). In short, ADRIA simulates a reef decision maker operating inside the dynamic state space of a coral reef.","category":"page"},{"location":"synopsis/","page":"Synopsis","title":"Synopsis","text":"For reef managers, ADRIA help provide line of sight to conservation solutions in complex settings where multiple objectives need to be considered. For investors, ADRIA helps analysts identify which options (R&D and/or deployment solutions) might have the highest likelihood of providing ecological and social returns on investment across a range of considered environmental conditions. While ADRIA’s key function is as a decision-support tool for intervention deployment, it uses a simple proxy model for reef coral dynamics, consisting of vital rates parameterised in a set of linked differential equations for four coral groups. The growth, mortality and recruitment of those four coral groups are further parameterised by environmental drivers and by different restoration and adaptation interventions.","category":"page"},{"location":"synopsis/","page":"Synopsis","title":"Synopsis","text":"The primary purpose of ADRIA is to help guide intervention deployment such that net benefits are maximised against primary objectives and minimised against costs. Solutions can be tuned (eventually optimised) via heuristics that control the selection of sites and/or reefs and the prioritisation of species, ecosystem services or benefits that favour what people (society) want. The key benefits considered in ADRIA are consistent with a triple-bottom-line approach, i.e.","category":"page"},{"location":"synopsis/","page":"Synopsis","title":"Synopsis","text":"ecological (e.g. biodiversity),\neconomic (e.g. tourism and fisheries values) and\nsocial and cultural (e.g. recreation and supporting identities).","category":"page"},{"location":"synopsis/","page":"Synopsis","title":"Synopsis","text":"The guiding principles for decision support in ADRIA are currently a set of dynamic Multi-Criteria Decision Analyses (dMCDA) applied at each time step. Criteria in the model are a composite of spatial environmental variables (risk from wave damage, thermal stress, and water quality) and ecological information (coral cover, substrate availability).","category":"page"},{"location":"development/development_setup/#Development-setup","page":"Development setup","title":"Development setup","text":"","category":"section"},{"location":"development/development_setup/#Install-Julia","page":"Development setup","title":"Install Julia","text":"","category":"section"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"Install Julia if not already done so, preferably using juliaup.","category":"page"},{"location":"development/development_setup/#Windows","page":"Development setup","title":"Windows","text":"","category":"section"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"There may be issues installing juliaup from the Windows Store (or otherwise undesirable). In such cases, use the alternate MSIX App installer (https://install.julialang.org/Julia.appinstaller)","category":"page"},{"location":"development/development_setup/#Recommendations","page":"Development setup","title":"Recommendations","text":"","category":"section"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"It is recommended that the juliaup tool be used to ease managing Julia versions.\nWe recommend VS Code with its Julia extension when developing ADRIA.\nWe also recommend the built-in Julia REPL within VS Code be used (see the notes below).","category":"page"},{"location":"development/development_setup/#Initial-Setup","page":"Development setup","title":"Initial Setup","text":"","category":"section"},{"location":"development/development_setup/#Using-the-console","page":"Development setup","title":"Using the console","text":"","category":"section"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"Once Julia is installed, clone the ADRIA.jl repository and navigate to the project folder:","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"$ git clone git@github.com:open-AIMS/ADRIA.jl.git\n$ cd ./ADRIA.jl","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"Start Julia specifying the current directory as the project environment:","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"$ julia --project=.","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"Switch to the package manager (]) and instantiate the project. This only needs to be done once.","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"julia> ]\n(ADRIA.jl) pkg> instantiate","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"This will sets up the project packages.","category":"page"},{"location":"development/development_setup/#Sandbox","page":"Development setup","title":"Sandbox","text":"","category":"section"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"For development purposes, set up a sandbox environment (setup only needs to be done once). This environment will function as a project apart from ADRIA, where you can install any packages, including ADRIA.jl, and run your code. When installing ADRIA.jl at the sandbox, use the dev command instead of add. For more information, please refer to Pkg.jl documentation.","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"Once you are inside ADRIA.jl project folder, create a folder named sandbox and start julia inside it:","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"$ mkdir sandbox\n$ cd sandbox\n$ julia --project=.","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"Switch to the package manager (]) and add ADRIA.jl as a local package under development","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"julia> ]\n(sandbox) pkg> dev ../","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"You may also install additional packages for visualizations and debugging tools","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"(sandbox) pkg> add GLMakie GeoMakie GraphMakie\n(sandbox) pkg> add Revise Infiltrator BenchmarkTools JET","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"Press backspace or Ctrl+C to leave the package manager.","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"Development scripts/functions can now be worked on in the sandbox folder, and its sub-folders, without these polluting the ADRIA project itself.","category":"page"},{"location":"development/development_setup/#Testing","page":"Development setup","title":"Testing","text":"","category":"section"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"To run the full test suite, rebuilding the environment as necessary:","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"$ julia --project=.\njulia> ]test","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"Rebuilding the environment can be unnecessary for every test run during development. It such cases, include() the runtests.jl file directly.","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"# Assuming the current working directory is the project root.\n# Adjust the filepath as necessary if this is not the case.\ninclude(\"test/runtests.jl\")","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"If a specific test case is being run, write the test file to be a standalone script (importing all necessary packages, including Test) and run it directly.","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"Doing so allows use of debugging packages if necessary.","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"include(\"test/some_test_file.jl\")","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"Once the test is complete, put the tests in a testset as and if required. If a new file is added to the test suite, include() it in test/runtests.jl","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"See the Test documentation for further details.","category":"page"},{"location":"development/development_setup/#Code-Style","page":"Development setup","title":"Code Style","text":"","category":"section"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"We are currently moving to follow Blue Style Guide. All PRs should follow this style guide.","category":"page"},{"location":"development/development_setup/#Notes","page":"Development setup","title":"Notes","text":"","category":"section"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"The very first import of the ADRIA package will be very slow as it attempts to precompile common functions to reduce later start up time. The same applies when running ADRIA for the first time. This slow initial precompilation has to be repeated if the package is modified, but will remain \"fast\" if no changes are made.","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"Use the Revise package to avoid having to repeatedly restart the REPL to incorporate code changes. By default, the VS Code REPL will auto-load this package.","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"A custom sysimage can also be created to reduce start up times.","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"VS Code now has (experimental) support for generating a custom sysimage for its REPL. Prior to Julia v1.9, a custom sysimage for the development/sandbox environment was highly recommended. Julia v1.9 introduced an improved precompilation process and the concept of extension packages. As many packages are still in the process of taking advantage of these changes, the sysimage may not successfully build. Given precompilation is now much faster than previously, the sysimage can be considered to be a \"nice to have\".","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"The same caveats as above apply: the sysimage has to be recreated if the project specification (e.g., expected package dependencies) changes.","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"See: This guide","category":"page"},{"location":"development/development_setup/","page":"Development setup","title":"Development setup","text":"Otherwise, if the VS Code build task cannot be used, see the documentation here for a quick how to. Note: compilation time to create a sysimage can be upwards of 15mins and, again, has to be repeated if the project packages are updated.","category":"page"},{"location":"usage/cookbook/#Cookbook-examples","page":"Cookbook examples","title":"Cookbook examples","text":"","category":"section"},{"location":"usage/cookbook/#Extracting-model-details","page":"Cookbook examples","title":"Extracting model details","text":"","category":"section"},{"location":"usage/cookbook/","page":"Cookbook examples","title":"Cookbook examples","text":"Example showcasing how to extract model details, such as:","category":"page"},{"location":"usage/cookbook/","page":"Cookbook examples","title":"Cookbook examples","text":"the model parameter table\nmodel specification","category":"page"},{"location":"usage/cookbook/","page":"Cookbook examples","title":"Cookbook examples","text":"and more specific information/data from the above.","category":"page"},{"location":"usage/cookbook/","page":"Cookbook examples","title":"Cookbook examples","text":"using DataFrames\nusing ADRIA\n\n\n# Loading a dataset for a study area (a \"domain\")\ndata_pkg = \"./Example_domain\"\ndom = ADRIA.load_domain(data_pkg, 45)\n\n# Get current parameter table (fieldnames and their values)\nparam_df = ADRIA.param_table(dom)\n\n# Get model specification with lower/upper bounds separated\nmodel_spec = ADRIA.model_spec(dom)\n\n# Export model specification to CSV\nADRIA.model_spec(dom, \"model_spec.csv\")\n\n\n# Get parameter details\n\n## Parameter names\np_names = dom.model[:fieldname]\n\n## Current values\np_vals = dom.model[:val]\n\n## ADRIA parameter types\np_types = dom.model[:ptype]\n\n## Parameter bounds (for e.g., to pass into a sampler or optimizer)\n## Note: ADRIA integer parameter bounds are set such that ℓ ≤ x ≤ u+1,\n## where ℓ is the lower bound and u is the upper bound.\n## This is because `floor(x)` is assigned with `update_params!()`.\n## Instances where ℓ := x := u indicate uncertain parameters that\n## are nevertheless assumed to be constant.\np_bounds = dom.model[:bounds]\n\n## Component groups\np_groups = dom.model[:component]\n\n## All of above as a DataFrame\nmodel_spec = DataFrame(dom.model)\n\n\n# Get DataFrame of parameter information for a specific sub-component (Intervention, Criteria, Coral)\nADRIA.component_params(dom.model, Intervention)","category":"page"},{"location":"usage/cookbook/#Generating-and-running-scenarios","page":"Cookbook examples","title":"Generating and running scenarios","text":"","category":"section"},{"location":"usage/cookbook/","page":"Cookbook examples","title":"Cookbook examples","text":"using ADRIA\n\n\n# Loading data package\ndom = ADRIA.load_domain(\"Example_domain\")\n\n# Creating 128 scenarios based on parameter bounds using the Sobol' method\nscens = ADRIA.sample(dom, 128)\n\n# Can also use other samplers\n# using Surrogates.QuasiMonteCarlo\n# scens = ADRIA.sample(dom, 100, LatinHypercubeSample())\n\n# Can also sample counterfactuals (scenarios with no interventions)\n# or scenarios with guided interventions only\n# s = ADRIA.sample_cf(dom, 32)\n# s = ADRIA.sample_guided(dom, 32)\n\n# Can also load previously generated scenarios\n# p_df = ADRIA.load_scenarios(dom, joinpath(here, \"example_scenarios.csv\"))\n\n# Batch run scenarios. Returns a ResultSet.\n# Setting up and running scenarios\nrs = ADRIA.run_scenarios(dom, p_df, \"45\")\n\n# Multiple RCPs can be specified, so long as RCP-specific data is available.\n# rs = ADRIA.run_scenarios(dom, p_df, [\"45\", \"60\"])\n\n# Single scenario run (returns NamedTuple of results for a single environmental/intervention scenario).\n# See documentation for more detail.\n# scenario_id = 1\n# result = ADRIA.run_scenario(domain::Domain, scenario_id, param_df::DataFrameRow)\n\n# switch_RCPs!(domain, \"45\")\n# res1 = ADRIA.run_scenario(domain, scens[1, :])\n# res2 = ADRIA.run_scenario(domain, scens[2, :])\n# res3 = ADRIA.run_scenario(domain, scens[3, :], \"60\")  # run for a different RCP\n\n# The location of the outputs stored on disk\n@info ADRIA.store_name(rs)\n# \"Example_domain__RCPs45__2022-10-19_12_01_26_965\"\n\n@info ADRIA.result_location(rs)\n# \"[some location]/Example_domain__RCPs45__2022-10-19_12_01_26_965\"\n\n# Can also load results using a path to the stored result set.\n# rs = ADRIA.load_results(\"path to result set\")\n\n# Specific metrics found in the `metrics` submodule.\n# tac = ADRIA.metrics.total_absolute_cover(rs)","category":"page"},{"location":"usage/cookbook/#Intervention-location-selection","page":"Cookbook examples","title":"Intervention location selection","text":"","category":"section"},{"location":"usage/cookbook/","page":"Cookbook examples","title":"Cookbook examples","text":"using ADRIA\nusing ADRIA: rank_locations\n\n\ndom = ADRIA.load_domain(\"path to domain\", \"45\")\nscens = ADRIA.sample_site_selection(dom, 8)\n\n# Area of seeded corals in m^2\narea_to_seed = 962.11\n\n# Initial coral cover matching number of criteria samples (size = (no. criteria scens, no. of sites)).\nsum_cover = repeat(sum(dom.init_coral_cover; dims=1), size(scens, 1))\n\n# Use rank_locations to get ranks\nranks = rank_locations(dom, scens, sum_cover, area_to_seed)","category":"page"},{"location":"usage/cookbook/#Intervention-location-selection-summary-functions","page":"Cookbook examples","title":"Intervention location selection - summary functions","text":"","category":"section"},{"location":"usage/cookbook/","page":"Cookbook examples","title":"Cookbook examples","text":"using ADRIA\nusing ADRIA:\n    rank_locations,\n    ranks_to_frequencies,\n    location_selection_frequencies,\n    selection_score\nusing DataFrames\nusing Statistics, StatsBase\n\n# Load data package\ndom = ADRIA.load_domain(\"path to Domain files\", \"RCP\")\n\n# Select locations for interventions without any model runs\nscens = ADRIA.sample_site_selection(dom, 8)  # Get site selection scenario dataframe.\n\n# Area of seeded corals in m^2\narea_to_seed = 962.11\n\n# Initial coral cover matching number of criteria samples\nsum_cover = repeat(sum(dom.init_coral_cover; dims=1), size(scens, 1))\n\n# Use rank_locations to get ranks\nranks = rank_locations(dom, scens, sum_cover, area_to_seed)\n\n# Get frequencies with which each site is selected for each rank for set of stand alone\n# location selections\nrank_freq = ranks_to_frequencies(ranks[intervention=1])\n\n# Calculate rank aggregations\n# Get location selection freqencies for set of standalone location selections\nlocation_selection_frequency = location_selection_frequencies(ranks[intervention=1])\n\n# Get summed inverse rank for set of standalone location selections\n# Measure of magnitude and frequency of high rank\nsel_score = selection_score(ranks[intervention=1])\n\n# Use aggregation function within rank_locations to get direct output\n# To get rank frequencies:\nrank_frequencies_seed = rank_locations(\n    dom, scens, sum_cover, area_to_seed, ranks_to_frequencies, 1\n)\nrank_frequencies_seed = rank_locations(\n    dom, scens, sum_cover, area_to_seed, location_selection_frequencies, 1\n)\nrank_frequencies_seed = rank_locations(\n    dom, scens, sum_cover, area_to_seed, selection_score, 1\n)\n\n# Example using ADRIA runs\nscens = ADRIA.sample(dom, 8)\nrs = ADRIA.run_scenarios(dom, scens, \"45\")\n\n# Get frequencies with which each site was selected for each rank for a set of runs\nrank_freq = ranks_to_frequencies(rs.ranks[intervention=1])  # with timesteps not aggregated\n\n# With timesteps aggregated\nrank_freq = ranks_to_frequencies(\n    rs.ranks[intervention=1];\n    agg_func=x -> dropdims(sum(x; dims=:timesteps); dims=:timesteps),\n)\n\n# Get selection frequencies for set of runs\nselection_freq = location_selection_frequencies(rs.ranks[intervention=1])\n\n# Get selection frequencies over time for unguided runs only\nunguided_freq = location_selection_frequencies(\n    rs.seed_log[scenarios=findall(scens.guided .>= 1)]\n)\n\n# Get selection score for set of runs\n# Measure of magnitude and frequency of high rank\nsel_score = selection_score(rs.ranks[intervention=1])\n\n# Get selection score for locations over time\nsel_score = selection_score(rs.ranks[intervention=1]; dims=[:scenarios])","category":"page"},{"location":"architecture/architecture/#Architectural-overview","page":"Architectural overview","title":"Architectural overview","text":"","category":"section"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"ADRIA consists of three overarching components:","category":"page"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"a set of Multi-Criteria Decision Analysis methods used to emulate decision-makers\na coral ecosystem model (referred to as ADRIAmod)\na suite of analysis and assessment methods","category":"page"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"Each component may be applied separately, or altogether to perform an end-to-end analysis. This page documents the underlying architectural implementation of ADRIA, detailing how the above components interact.","category":"page"},{"location":"architecture/architecture/#General-Structure","page":"Architectural overview","title":"General Structure","text":"","category":"section"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"The primary purpose of ADRIA is to support reef restoration and adaptation through the development of robust intervention strategies under deep uncertainty. Here, \"robustness\" refers to the ability of an intervention strategy to meet desired outcomes under uncertain future conditions, which themselves are unknown and may be unexpected. To do so, ADRIA adopts an Exploratory Scenario Modelling framework to explore the range of possible futures and their outcomes.","category":"page"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"Exploratory Scenario Modelling (ESM) itself leverages uncertainty and sensitivity analysis (UA/SA). Uncertainty analysis quantifies the variability of uncertainties in a given system and its expected range of outcomes. Sensitivity analysis examines the effect of a change in a model's inputs to its outputs. Common workflows to such analyses involve a three-step process (as discussed in Pianosi et al., 2016):","category":"page"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"Input sampling\nModel evaluation\nPost-processing","category":"page"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"When ADRIA is applied in its entirety, \"input sampling\" is analogous to scenario generation: all model factors (the inputs) are collated and are sampled through a quasi-monte carlo process. The Sobol' sampling method is adopted as the default, although any method provided by the QuasiMonteCarlo.jl package can be used. Sample adjustment is required to map sampled values (which are continuous) to categorical or whole number values (e.g., Baroni and Tarantola, 2014) as may be expected by some factors. Values are also adjusted to avoid implausible factor combinations, such as active intervention factors in the case of non-intervention scenarios.","category":"page"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"Model evaluation is simply running the model with the generated scenario set.","category":"page"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"Post-processing is the analysis and visualization step.","category":"page"},{"location":"architecture/architecture/#Model-Factors","page":"Architectural overview","title":"Model Factors","text":"","category":"section"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"Factors in ADRIA are defined across four sub-components:","category":"page"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"Intervention\nCriteriaWeights\nEnvironmentalLayers\nCoral","category":"page"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"Each sub-component is represented by a struct with fields for each parameter. The Intervention sub-component holds parameters that define a given adopted intervention strategy/option: how many (and type of) corals are to be seeded, the length of any deployment, the start/end years, and so on. The CriteriaWeights sub-component relates to the preferences for the Multi-Criteria Decision Analysis methods, further detailed in Dynamic Multi-Criteria Decision Analysis. For the ADRIA ecosystem model (ADRIAmod), EnviromentalLayers relate to the environmental scenarios available for a given simulation (a time series of DHW and Wave stress), itself determined on the loading of data (see Running scenarios).","category":"page"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"The Coral sub-component relates to ADRIAmod, currently representing six coral species:","category":"page"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"Arborescent Acropora\nTabular Acropora\nCorymbose Acropora\nCorymbose non-Acropora\nSmall massives and encrusting\nLarge massives","category":"page"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"ADRIAmod represents these across six size classes, with six parameter sets for each coral species and size class. These six parameter sets are further detailed in Model Factors, however, it results in a large number of unique factors (6 groups x 6 size classes x 6 parameters: 216 factors). Instead of specifying all coral factors by hand, ADRIA instead auto-generates the sub-component using a common template (see coral_spec() and create_coral_struct() in General API). Through discussion with expert stakeholders, factor bounds were set to +/- 10% of their default values following a triangular distribution, the peak of which is the default value.","category":"page"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"The ModelParameters.jl package is used to provide a simple table-like interface to model factors. Using the Param type provided by ModelParameters.jl allows the default value, the factor bounds, their expected distribution, and other associated metadata (e.g., a human-readable name and description) to be attached. An example from the Intervention sub-component is shown below.","category":"page"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"guided::N = Param(0, ptype=\"integer\", bounds=(-1, 3 + 1), dists=\"unif\",\n        name=\"Guided\", description=\"Choice of MCDA approach.\")","category":"page"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"Note the + 1 in the example above when specifying the upper bound. Usual sampling approaches, such as the Sobol' method mentioned above, provide a continous value. These need to be transformed to a whole number when working with categorical factors or parameters which expect a whole number. A \"flooring trick\" (as it is referred to here) is adopted to handle this transformation. The process is described in Baroni and Tarantola (2014) and is illustrated here with the example below.","category":"page"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"Let x_i be a factor that is expected to be a discrete value between 1 and 3 (inclusive). In other words, there are 3 valid options: x_i = 1 2 3.","category":"page"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"The upper bound is increased by 1, such that x_i = 1 2 3 4\nSample from this extended range with the given sampler, which returns a value 1 le v_i lt 4, where v_i in mathbbR\nTake the floor of v_i. For example, if v_i = 39, then textfloor(v_i) = 3.","category":"page"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"In this manner the expected probability of a possible value being selected is maintained.","category":"page"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"These factor definitions are collectively known as the model specification, and can be collated as a DataFrame.","category":"page"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"Combination of the realized factor values then represent a \"scenario\".","category":"page"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"note: Parameter Collation and Scenario Generation\nSee Cookbook examples for an example how-to on collating model factors and generating samples.","category":"page"},{"location":"architecture/architecture/#References","page":"Architectural overview","title":"References","text":"","category":"section"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"Baroni, G., and S. Tarantola. 2014. A General Probabilistic Framework for uncertainty and global sensitivity analysis of deterministic models: A hydrological case study. Environmental Modelling & Software 51:26–34.","category":"page"},{"location":"architecture/architecture/","page":"Architectural overview","title":"Architectural overview","text":"Pianosi, F., K. Beven, J. Freer, J. W. Hall, J. Rougier, D. B. Stephenson, and T. Wagener. 2016. Sensitivity analysis of environmental models: A systematic review with practical workflow. Environmental Modelling & Software 79:214–232.","category":"page"},{"location":"development/release_guide/#Release-Guide","page":"Release Guide","title":"Release Guide","text":"","category":"section"},{"location":"development/release_guide/","page":"Release Guide","title":"Release Guide","text":"All releases are done on main.","category":"page"},{"location":"development/release_guide/","page":"Release Guide","title":"Release Guide","text":"Note: version numbers should follow Semantic Versioning.","category":"page"},{"location":"development/release_guide/#Public-\"Final\"-Releases","page":"Release Guide","title":"Public \"Final\" Releases","text":"","category":"section"},{"location":"development/release_guide/","page":"Release Guide","title":"Release Guide","text":"Increase the version number (manually) following SemVer in the Project.toml file\nUpdate environment and run tests locally to ensure all pass. Testing\nSubmit a PR with the updated version number. Wait for approval.\nOnce approved, go to the releases page   and click the \"Draft a new release\" button at the top right\nUnder \"Choose a tag\" on the left, enter the new version number (e.g., \"v0.99.0\") and then   select \"Create new tag: <TAG-NAME> on publish\"\nAt the top-right of the textbox, select the last full release then click the  \"Generate release notes\" button (at the top-right of the textbox).\nUnder \"What's Changed\" add a short description of the major changes.   Explicitly note any major breaking changes (i.e., anything that results obtained with previous versions of ADRIA incompatible) Copy the release notes (for step 8). Click \"Publish release\".\nRegister the updated package by opening a new issue with the title \"Register [version number]\"   e.g., Register v1.0\nState in the comment: @JuliaRegistrator register Paste in the generated text from step 6 (an example is shown below)\nSubmit the issue. The JuliaRegistrator bot should take care of the rest.","category":"page"},{"location":"development/release_guide/","page":"Release Guide","title":"Release Guide","text":"@JuliaRegistrator register\n\nRelease notes:\n\nPaste the generated release notes here.","category":"page"},{"location":"development/release_guide/","page":"Release Guide","title":"Release Guide","text":"See Julia Registrator usage notes here for more details.","category":"page"},{"location":"development/release_guide/","page":"Release Guide","title":"Release Guide","text":"note: Issues can block release\nThe JuliaRegistrator bot submits a corresponding Pull Request with the Julia package registry. Registration may be blocked for a number of reasons. Keep an eye on the auto-submitted Pull Request and resolve any issues reported there. Otherwise the package version will never be released.","category":"page"},{"location":"development/release_guide/#Development-Release","page":"Release Guide","title":"Development Release","text":"","category":"section"},{"location":"development/release_guide/","page":"Release Guide","title":"Release Guide","text":"Development releases provide users with the most recent \"working\" version of ADRIA and may still have some known bugs. It provides users a chance to try new features and/or provide feedback before a public release.","category":"page"},{"location":"development/release_guide/","page":"Release Guide","title":"Release Guide","text":"Deploying a Development Release follows the same steps as \"Public\" releases, except:","category":"page"},{"location":"development/release_guide/","page":"Release Guide","title":"Release Guide","text":"Add \"-dev.x\" to the version number.    e.g., v1.2.3-dev.1; v1.2.3-dev.2 for the second development release, etc.\nUntick \"Set as the latest release\" and tick the \"Set as a pre-release\" option.\nIgnore Step 8 through 10; DO NOT trigger the JuliaRegistrator bot.","category":"page"},{"location":"development/release_guide/#Release-Candidates","page":"Release Guide","title":"Release Candidates","text":"","category":"section"},{"location":"development/release_guide/","page":"Release Guide","title":"Release Guide","text":"Release candidates are releases that are not yet \"final\" but are close to it. Release candidates provide a \"last chance\" opportunity for users to report bugs prior to a \"final\" release.","category":"page"},{"location":"development/release_guide/","page":"Release Guide","title":"Release Guide","text":"Deploying a Release Candidate follows the same steps as \"Public\" releases, except:","category":"page"},{"location":"development/release_guide/","page":"Release Guide","title":"Release Guide","text":"Add \"-rc.x\" to the version number.    e.g., v1.2.3-rc.1; v1.2.3-rc.2 for the second release candidate, etc.\nUntick \"Set as the latest release\" and tick the \"Set as a pre-release\" option.\nIgnore Step 8 through 10; DO NOT trigger the JuliaRegistrator bot.","category":"page"},{"location":"usage/scenario_generation/#Generating-scenarios","page":"Generating scenarios","title":"Generating scenarios","text":"","category":"section"},{"location":"usage/scenario_generation/","page":"Generating scenarios","title":"Generating scenarios","text":"Typical use of ADRIA is to generate a number of scenarios by sampling from combinations of possible factors relating to environmental, intervention, and coral conditions.","category":"page"},{"location":"usage/scenario_generation/","page":"Generating scenarios","title":"Generating scenarios","text":"A scenario is defined as a combination of all factors (i.e., all the model inputs).","category":"page"},{"location":"usage/scenario_generation/","page":"Generating scenarios","title":"Generating scenarios","text":"# Load domain before generating scenarios\ndom = ADRIA.load_domain(\"path to domain data package\")\n\n# Generate 128 scenarios based on available environmental data layers and model parameters\nscens = ADRIA.sample(dom, 128)","category":"page"},{"location":"usage/scenario_generation/","page":"Generating scenarios","title":"Generating scenarios","text":"Here, the scens variable holds a DataFrame of scenarios of shape N by D, where N is the number of scenarios (rows) and D is the number of factors (columns). Because it is a DataFrame, it can be modified after the fact.","category":"page"},{"location":"usage/scenario_generation/","page":"Generating scenarios","title":"Generating scenarios","text":"The Sobol' method (Sobol' 1993, 2001) is the default sampling approach. It is a deterministic low-discrepancy quasi-monte carlo sampler. Samples are described as having low discrepancy if the samples are equi-distributed, and thus guarantee an even exploration of parameter space. One limitation of the Sobol' method is that  all factors are assumed to be independent. For most factors represented in ADRIA, this assumption holds true. Specific factors relating to intervention options may conditionally co-vary however, and this dependency is introduced by adjusting the sample values a posteriori to restrict sampled values to their plausible  combinations, and to map continuous values to their expected discrete factor values (where necessary), as is in the case with categorical factors. The Sobol' scheme is therefore disrupted due to the adjustment and so a Sobol' sensitivity analysis may exhibit comparatively poor convergence. Subsequent assessment of  uncertainty and sensitivity is instead conducted with the distribution-based  PAWN method (Pianosi and Wagener 2015, 2018).","category":"page"},{"location":"usage/scenario_generation/","page":"Generating scenarios","title":"Generating scenarios","text":"note: Sobol' samples\nThe convergence properties of the Sobol' sequence is only valid if the number of samples is a power of 2.","category":"page"},{"location":"usage/scenario_generation/","page":"Generating scenarios","title":"Generating scenarios","text":"Samples for factors with non-uniform distributions are transformed to their indicated distributions using the Inverse Cumulative Distribution Function method.","category":"page"},{"location":"usage/scenario_generation/","page":"Generating scenarios","title":"Generating scenarios","text":"Although the Sobol' method is the default, any sampler supported by the Surrogates.jl package may be used. Below is an example using Latin Hypercube sampling.","category":"page"},{"location":"usage/scenario_generation/","page":"Generating scenarios","title":"Generating scenarios","text":"import Surrogates.QuasiMonteCarlo: LatinHypercubeSample\n\nscens = ADRIA.sample(dom, 100, LatinHypercubeSample())","category":"page"},{"location":"usage/scenario_generation/#On-model-parameters-and-specifications","page":"Generating scenarios","title":"On model parameters and specifications","text":"","category":"section"},{"location":"usage/scenario_generation/","page":"Generating scenarios","title":"Generating scenarios","text":"The current default values can be extracted with:","category":"page"},{"location":"usage/scenario_generation/","page":"Generating scenarios","title":"Generating scenarios","text":"params = ADRIA.param_table(dom)","category":"page"},{"location":"usage/scenario_generation/","page":"Generating scenarios","title":"Generating scenarios","text":"Again, params is a DataFrame of a single row and D factors: A single scenario with model factors set to their default values.","category":"page"},{"location":"usage/scenario_generation/","page":"Generating scenarios","title":"Generating scenarios","text":"Running specific user-defined scenarios is as simple as modifying the DataFrame (referred to as the \"scenario specification\"). A set of scenarios may be specified  simply by extending the number of rows of the DataFrame. Details of the ADRIA  model - parameter names, the default values, and their bounds - can be extracted as well.","category":"page"},{"location":"usage/scenario_generation/","page":"Generating scenarios","title":"Generating scenarios","text":"# Get model specification\nmodel_spec = ADRIA.model_spec(dom)\n\n# Sometimes it is useful to export the model specification to CSV\nADRIA.model_spec(dom, \"model_spec.csv\")","category":"page"},{"location":"usage/scenario_generation/#Constrained-sampling","page":"Generating scenarios","title":"Constrained sampling","text":"","category":"section"},{"location":"usage/scenario_generation/","page":"Generating scenarios","title":"Generating scenarios","text":"At times, it is necessary to create samples while holding some model factors constant.","category":"page"},{"location":"usage/scenario_generation/","page":"Generating scenarios","title":"Generating scenarios","text":"Although a scenario set could be modified to make specific factors constant, doing so runs the risk of creating (many) identical scenarios, thereby wasting computational effort. A more efficient approach is to modify the model specification itself to treat those factors as constants. These then get ignored for the purpose of scenario generation.","category":"page"},{"location":"usage/scenario_generation/","page":"Generating scenarios","title":"Generating scenarios","text":"dom = ADRIA.load_domain()\n\n# Could keep a copy of the original model parameters/bounds\n# to reset to later.\n# orig_spec = DataFrame(dom.model)\n\n# Make the assisted adaptation factor a constant\nADRIA.fix_factor!(dom, :a_adapt)\n\n# Set the assisted adaptation factor to a given constant value\nADRIA.fix_factor!(dom, :a_adapt, 3.0)\n\n# Pass in factor names and their constant values as named arguments\n# to fix a set of factors.\nADRIA.fix_factor!(dom;\n    seed_TA=Int64(5e5),\n    seed_CA=Int64(5e5),\n    SRM=0.0,  # Never fog/shade\n    fogging=0.0,\n    a_adapt=3.0,  # only deploy +3 DHW enhanced corals\n    seed_years=5,\n    shade_years=0,\n    seed_freq=0,\n    shade_freq=0,\n    seed_year_start=3,\n    shade_year_start=3,\n    coral_cover_tol=1.0\n)","category":"page"},{"location":"usage/scenario_generation/","page":"Generating scenarios","title":"Generating scenarios","text":"Samples can also be taken over a constrained range. For example, if one wanted to investigate only  scenarios with high fogging and seeding, the following could be used:","category":"page"},{"location":"usage/scenario_generation/","page":"Generating scenarios","title":"Generating scenarios","text":"dom = ADRIA.load_domain()\n\n# Adjust seeding bounds. Note only lower and upper bounds are needed because the factors in  \n# question have a uniform distribution.\nADRIA.set_factor_bounds!(dom, :N_seed_TA, (500000.0, 1000000.0 + 1.0))\nADRIA.set_factor_bounds!(dom, :N_seed_CA, (500000.0, 1000000.0 + 1.0))\nADRIA.set_factor_bounds!(dom, :N_seed_SA, (500000.0, 1000000.0 + 1.0))\n\n# Adjust fogging bounds. Note lower, upper and mode parameters are needed because it \n# is a triangular distribution.\nADRIA.set_factor_bounds!(dom, :fogging, (0.2, 0.3, 0.1))\n\n# Adjust multiple factors simultaneously.\nADRIA.set_factor_bounds!(dom;\n    heat_stress=(0.3, 0.7),\n    N_seed_TA=(500000.0, 1000000.0 + 1.0),\n    N_seed_CA=(500000.0, 1000000.0 + 1.0))","category":"page"},{"location":"usage/scenario_generation/#Sampling-counterfactuals-only","page":"Generating scenarios","title":"Sampling counterfactuals only","text":"","category":"section"},{"location":"usage/scenario_generation/","page":"Generating scenarios","title":"Generating scenarios","text":"A convenience function to create scenarios with no interventions (counterfactuals).","category":"page"},{"location":"usage/scenario_generation/","page":"Generating scenarios","title":"Generating scenarios","text":"cf_scens = ADRIA.sample_cf(dom, 1024)","category":"page"},{"location":"usage/scenario_generation/#References","page":"Generating scenarios","title":"References","text":"","category":"section"},{"location":"usage/scenario_generation/","page":"Generating scenarios","title":"Generating scenarios","text":"Sobol’, I. M. 1993. Sensitivity analysis for non-linear mathematical models. Mathematical Modelling and Computational Experiment 1:407–414. [Translated from Russian, accessible at: https://www.mathnet.ru/php/archive.phtml?wshow=paper&jrnid=mm&paperid=2320&option_lang=eng]\nSobol′, I. M. 2001. Global sensitivity indices for nonlinear mathematical models and their Monte Carlo estimates. Mathematics and Computers in Simulation 55:271–280. https://doi.org/10.1016/S0378-4754(00)00270-6\nPianosi, F., and T. Wagener. 2015. A simple and efficient method for global sensitivity analysis based on cumulative distribution functions. Environmental Modelling & Software 67:1–11. https://dx.doi.org/10.1016/j.envsoft.2015.01.004\nPianosi, F., and T. Wagener. 2018. Distribution-based sensitivity analysis from a generic input-output sample. Environmental Modelling & Software 108:197–207. https://dx.doi.org/10.1016/j.envsoft.2018.07.019","category":"page"},{"location":"usage/domain/#Loading-a-Domain","page":"Loading a Domain","title":"Loading a Domain","text":"","category":"section"},{"location":"usage/domain/","page":"Loading a Domain","title":"Loading a Domain","text":"ADRIA is designed to work with Domain data packages. In short, these are pre-packaged data sets that hold all the necessary data to run simulations for a given spatial domain.","category":"page"},{"location":"usage/domain/","page":"Loading a Domain","title":"Loading a Domain","text":"See Architectural overview for more information.","category":"page"},{"location":"usage/domain/","page":"Loading a Domain","title":"Loading a Domain","text":"A Domain may be loaded with the load_domain function. By convention we assign the Domain to dom, although this variable can be named anything.","category":"page"},{"location":"usage/domain/","page":"Loading a Domain","title":"Loading a Domain","text":"dom = ADRIA.load_domain(\"path to domain data package\")","category":"page"},{"location":"usage/domain/","page":"Loading a Domain","title":"Loading a Domain","text":"ReefMod Engine datasets can also be used to run ADRIAmod simulations for the Great Barrier Reef.","category":"page"},{"location":"usage/domain/","page":"Loading a Domain","title":"Loading a Domain","text":"dom = ADRIA.load_domain(ReefModDomain, \"path to ReefModEngine dataset\", \"45\")","category":"page"},{"location":"usage/domain/","page":"Loading a Domain","title":"Loading a Domain","text":"Note that at the moment the target RCP has to be specified.","category":"page"},{"location":"usage/scenario_runs/#Running-scenarios","page":"Running scenarios","title":"Running scenarios","text":"","category":"section"},{"location":"usage/scenario_runs/","page":"Running scenarios","title":"Running scenarios","text":"# Run sampled scenarios for a given RCP\nrs = ADRIA.run_scenarios(dom, scens, \"45\")\n\n# ... or repeat scenario runs across multiple RCPs\nrs = ADRIA.run_scenarios(dom, scens, [\"45\", \"60\", \"85\"])\n\n# The location of the outputs stored on disk\n@info ADRIA.store_name(rs)\n# \"Example_domain__RCPs45__2022-10-19_12_01_26_965\"\n\n@info ADRIA.store_location(rs)\n# \"[some location]/Example_domain__RCPs45__2022-10-19_12_01_26_965\"","category":"page"},{"location":"usage/scenario_runs/","page":"Running scenarios","title":"Running scenarios","text":"The rs variable is an ResultSet object which acts as an interface to the stored results.","category":"page"},{"location":"usage/scenario_runs/","page":"Running scenarios","title":"Running scenarios","text":"The ResultSet provides:","category":"page"},{"location":"usage/scenario_runs/","page":"Running scenarios","title":"Running scenarios","text":"An overview of scenarios run\nAccess to results from key ADRIA metrics\nSeeding/Shading/Fogging logs\ndomain spatial data","category":"page"},{"location":"usage/scenario_runs/","page":"Running scenarios","title":"Running scenarios","text":"print(rs)","category":"page"},{"location":"usage/scenario_runs/","page":"Running scenarios","title":"Running scenarios","text":"note: on-disk data store\nADRIA uses an on-disk data store (in Zarr format) to reduce memory use. The primary location for these is defined in the project's config.toml file (see instructions in Getting Started).","category":"page"},{"location":"usage/scenario_runs/","page":"Running scenarios","title":"Running scenarios","text":"tip: Reloading results\nPre-existing results can also be reloaded by providing the path to the data store.rs = ADRIA.load_results(\"path to result set\")","category":"page"},{"location":"dMCDA/#Dynamic-Multi-Criteria-Decision-Analysis","page":"Dynamic Multi-Criteria Decision Analysis","title":"Dynamic Multi-Criteria Decision Analysis","text":"","category":"section"},{"location":"development/metrics/#Contributing-a-metric","page":"Contributing a metric","title":"Contributing a metric","text":"","category":"section"},{"location":"development/metrics/","page":"Contributing a metric","title":"Contributing a metric","text":"At a minimum, all metrics must define:","category":"page"},{"location":"development/metrics/","page":"Contributing a metric","title":"Contributing a metric","text":"a \"private\" function (i.e., one that starts with an underscore: _) that performs the calculation with expected arguments\na \"private\" function that accepts a ResultSet as its first argument.\na \"public\" Metric function (i.e., no underscore) with some additional metadata","category":"page"},{"location":"development/metrics/","page":"Contributing a metric","title":"Contributing a metric","text":"The Metric type allows metadata regarding the expected dimension names and unit of measure. Note that the unit of measure is optional and can be left out.","category":"page"},{"location":"development/metrics/","page":"Contributing a metric","title":"Contributing a metric","text":"Below is the implementation of the total_absolute_cover metric.","category":"page"},{"location":"development/metrics/","page":"Contributing a metric","title":"Contributing a metric","text":"function _total_absolute_cover(X::AbstractArray{<:Real}, site_area::Vector{<:Real})::AbstractArray{<:Real}\n    return dropdims(sum(X, dims=:species), dims=:species) .* site_area'\nend\nfunction _total_absolute_cover(rs::ResultSet)::AbstractArray{<:Real}\n    return rs.outcomes[:total_absolute_cover]\nend\ntotal_absolute_cover = Metric(_total_absolute_cover, (:timesteps, :sites, :scenarios), \"m²\")\n\n# Unit of measure is optional, in cases where the values are non-dimensional\n# some_example_metric = Metric(_some_example_metric, (:timesteps, :scenarios))","category":"page"},{"location":"architecture/domain_and_resultsets/#Inputs-and-Outputs","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"","category":"section"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"ADRIA seeks to use Data Packages to define a standard structure, format, and naming convention for its inputs and outputs. By definition, a Data Package is a directory holding the required data for ADRIA to run, or results from model runs.","category":"page"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"Data specifications are outlined/stored in this repository: https://github.com/open-AIMS/ADRIA-data-specs","category":"page"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"The overall structure and data formats of the data packages are illustrated in the diagram below.","category":"page"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"(Image: Domain-Results Diagram)","category":"page"},{"location":"architecture/domain_and_resultsets/#Domain-data-package","page":"Inputs and Outputs","title":"Domain data package","text":"","category":"section"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"Prior to running the ADRIA coral ecosystem model, the first step (after importing the package) is to load domain data.","category":"page"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"dom = ADRIA.load_domain(\"path to some domain\")","category":"page"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"As the naming suggests, inputs are taken to represent a given spatial area, and so are referred to as a Domain.","category":"page"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"The Domain data package consists of:","category":"page"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"Connectivity (CSVs, grouped by year)\nDegree-Heating Week trajectories (in netCDF format; dimensions: timestep ⋅ location ⋅ projection)\nWave stress (as netCDFs; dimensions: timestep ⋅ location ⋅ projection)\nGeospatial data\na datapackage.json file with machine-readable metadata\na README.md file with human-readable content","category":"page"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"Geospatial data consists of:","category":"page"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"polygons defining individual reefs/sites in geopackage format\ninitial coral cover (as a netCDF; with dimensions: species/sizes ⋅ locations)","category":"page"},{"location":"architecture/domain_and_resultsets/#ReefMod-Engine-datasets","page":"Inputs and Outputs","title":"ReefMod Engine datasets","text":"","category":"section"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"Datasets intended for use with the ReefMod Engine (RME) can also be loaded for use with ADRIAmod. The RME represents larger spatial scales typically covering the entire Great Barrier Reef.","category":"page"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"dom = ADRIA.load_domain(ReefModDomain, \"path to ReefMod Engine dataset\", \"45\")","category":"page"},{"location":"architecture/domain_and_resultsets/#Naming-conventions","page":"Inputs and Outputs","title":"Naming conventions","text":"","category":"section"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"By convention, the directory name is typically the name of the reef or reef cluster. Where multiple datasets for the same spatial domain are expected, appending a unique suffix is recommended, such as the date of creation, such as \"Moore_2022-11-17\".","category":"page"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"The geopackage is expected to have the same filename as its Domain. For example, if the domain name is \"Example_domain\", then the geopackage file should be named \"Example_domain.gpkg\".","category":"page"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"Degree-heating Week datasets must follow the convention of: dhwRCP[NN].nc","category":"page"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"Here, [NN] is to be replaced with the two digit RCP code that indicates which RCP scenario is represented by the given data cube. The following are examples of valid/expected filenames:","category":"page"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"dhwRCP26.nc\ndhwRCP34.nc\ndhwRCP45.nc\ndhwRCP60.nc\ndhwRCP70.nc\ndhwRCP85.nc","category":"page"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"Similarly, below are examples of valid/expected wave stress filenames:","category":"page"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"wave_RCP26.nc\nwave_RCP34.nc\nwave_RCP45.nc\nwave_RCP60.nc\nwave_RCP70.nc\nwave_RCP85.nc","category":"page"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"Below is a diagram indicating the directory layout","category":"page"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"Example_domain\n│   datapackage.json\n│   README.md\n│\n├───connectivity\n│   ├───2015\n│   │       connect_matrix_2015_1.csv\n│   │       connect_matrix_2015_2.csv\n│   │       connect_matrix_2015_3.csv\n│   │\n│   ├───2016\n│   │       connect_matrix_2016_1.csv\n│   │       connect_matrix_2016_2.csv\n│   │       connect_matrix_2016_3.csv\n│   │\n│   └───2017\n│           connect_matrix_2017_1.csv\n│           connect_matrix_2017_2.csv\n│           connect_matrix_2017_3.csv\n│\n├───DHWs\n│       dhwRCP26.nc\n│       dhwRCP45.nc\n│       dhwRCP60.nc\n│       dhwRCP85.nc\n│\n├───site_data\n│       coral_cover.nc\n│       Example_domain.gpkg\n│\n└───waves\n        wave_RCP26.nc\n        wave_RCP45.nc\n        wave_RCP60.nc\n        wave_RCP85.nc","category":"page"},{"location":"architecture/domain_and_resultsets/#ResultSets","page":"Inputs and Outputs","title":"ResultSets","text":"","category":"section"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"The directory holding results is also treated as a data package referred to as a ResultSet. Scenario outcomes are written out to disk as they complete to a directory located in the user-defined Output directory (see Getting started).","category":"page"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"The directory name follows the convention of [Domain Name]__[IDs of RCPs]__[date/time of run]. For example: Moore_2022-11-17__RCPs45_60__2023-01-01_19_00_00_000","category":"page"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"The above example ResultSet indicates the \"Moore_2022-11-17\" Domain was run for RCPs 4.5 and 6.0 at precisely 7pm (i.e., 19:00:00.000, where the trailing \"000\" indicates milliseconds). Note that each \"portion\" of information is separated by a double underscore (__).","category":"page"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"Simulation results are stored in Zarr format. A ResultSet also holds a copy of:","category":"page"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"the scenario specifications\nthe geospatial data used\nSummary statistics for the DHW/wave scenarios run, and\nLogs indicating which locations were intervened on","category":"page"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"Below is a diagram of the directory structure. Filenames are not shown here as there may be hundreds/thousands depending on the scenario set run.","category":"page"},{"location":"architecture/domain_and_resultsets/","page":"Inputs and Outputs","title":"Inputs and Outputs","text":"Example_domain__RCP45_60_85__2023-03-11_19_00_00_000\n├───env_stats\n│   ├───dhw\n│   │   ├───45\n│   │   ├───60\n│   │   └───85\n│   └───wave\n│       ├───45\n│       ├───60\n│       └───85\n├───inputs\n├───logs\n│   ├───fog\n│   ├───rankings\n│   ├───seed\n│   └───shade\n├───model_spec\n├───results\n│   ├───absolute_shelter_volume\n│   ├───relative_juveniles\n│   ├───relative_shelter_volume\n│   ├───relative_taxa_cover\n│   └───total_absolute_cover\n└───site_data","category":"page"},{"location":"usage/getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"usage/getting_started/#Setup","page":"Getting Started","title":"Setup","text":"","category":"section"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"This section outlines how ADRIA may be used to arrive at a select range of possible pathways that are robust to possible future conditions.","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"Create a directory for your project, and start Julia inside that directory:","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"$ julia --project=.","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"ADRIA may be installed through the package manager or from the github repository (for the most recent development version).","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> ]add ADRIA\n\n# OR, to install the latest development version:\n\njulia> ]add https://github.com/open-AIMS/ADRIA.jl.git","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"Similarly, ADRIA can be updated as new releases are made:","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> ]up ADRIA","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"If desired, you can create a config.toml file inside your project directory. This is optional, and the assumed default values are shown below:","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"[operation]\nnum_cores = 2     # No. of cores to use. Values <= 0 will use all available cores.\nthreshold = 1e-8  # Result values below this will be set to 0.0 (to save disk space)\ndebug = false     # Disable multi-processing to allow error messages to be shown\n\n[results]\noutput_dir = \"./Outputs\"  # Change this to point to where you want to store results","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"This config.toml file is specific to your computer and project. It should not be committed to version control.","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"tip: Performance\nADRIA uses an on-disk data store to hold results from model runs. Setting output_dir to a directory on an SSD (Solid State Drive) will maximize performance.","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"To setup ADRIA for development, see the Development setup page.","category":"page"},{"location":"usage/getting_started/#Quick-Start","page":"Getting Started","title":"Quick Start","text":"","category":"section"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"A common workflow would be the following:","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"Start Julia from the project directory:","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"$ julia --project=.","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"Load data for a spatial domain. See Loading a Domain for more details:","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"using ADRIA\n\ndom = ADRIA.load_domain(\"path to domain data package\")","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"Generate scenarios based on available environmental data layers and model parameters. The number of scenarios shoud be a power of two. See Generating scenarios for more details:","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"num_scenarios = 128\nscens = ADRIA.sample(dom, num_scenarios)","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"Run sampled scenarios for one or more RCPs. Be aware that this may take a while:","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"rcp_45 = \"45\"\nrs = ADRIA.run_scenarios(dom, scens, rcp_45)","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"Or run scenarios across several RCPs:","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"rcps = [\"45\", \"60\", \"85\"]\nrs = ADRIA.run_scenarios(dom, scens, rcps)","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"It is also possible to load previously run scenarios. See Running scenarios for more details:","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"rs = ADRIA.load_results(\"path to results\")","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"Extract some metric for analysis (e.g., the total absolute cover for each site and timestep):","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"s_tc = ADRIA.metrics.scenario_total_cover(rs)","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"Use the visualization tools to plot the results. The Makie package ecosystem is used for producing plots:","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"using GLMakie, GeoMakie, GraphMakie\n\n# Plot a quick scenario overview\nfig = ADRIA.viz.scenarios(rs, s_tc; axis_opts=Dict(:ylabel=>\"Absolute Cover\"))\nsave(\"path_to_save_figure\", fig)","category":"page"},{"location":"usage/getting_started/","page":"Getting Started","title":"Getting Started","text":"See Analysis for further examples of analysis and plots.","category":"page"},{"location":"API/#ADRIA-API","page":"ADRIA API","title":"ADRIA API","text":"","category":"section"},{"location":"API/#Metrics","page":"ADRIA API","title":"Metrics","text":"","category":"section"},{"location":"API/","page":"ADRIA API","title":"ADRIA API","text":"Modules = [ADRIA.metrics]\nOrder   = [:constant, :function, :type]\nPrivate = true","category":"page"},{"location":"API/#ADRIA.metrics.absolute_juveniles","page":"ADRIA API","title":"ADRIA.metrics.absolute_juveniles","text":"absolute_juveniles(X::AbstractArray{T}, coral_spec::DataFrame, area::AbstractVector{T})::AbstractArray{T} where {T<:Real}\nabsolute_juveniles(rs::ResultSet)::AbstractArray\n\nJuvenile coral cover in m².\n\n\n\n\n\n","category":"constant"},{"location":"API/#ADRIA.metrics.absolute_shelter_volume","page":"ADRIA API","title":"ADRIA.metrics.absolute_shelter_volume","text":"absolute_shelter_volume(X::NamedDimsArray, site_area::Vector{<:Real}, inputs::Union{DataFrame,DataFrameRow})\nabsolute_shelter_volume(rs::ResultSet)\n\nProvide indication of shelter volume in volume of cubic meters.\n\nThe metric applies log-log linear models developed by Urbina-Barreto et al., [1] which uses colony diameter and planar area (2D metrics) to estimate shelter volume (a 3D metric).\n\nArguments\n\nX : raw results\nsite_area : area in m^2 for each site\nmax_cover : maximum possible coral cover for each site (in percentage of site_area)\ninputs : DataFrame of scenario inputs\n\nReferences\n\nUrbina-Barreto, I., Chiroleu, F., Pinel, R., Fréchon, L., Mahamadaly, V.,   Elise, S., Kulbicki, M., Quod, J.-P., Dutrieux, E., Garnier, R.,   Henrich Bruggemann, J., Penin, L., & Adjeroud, M. (2021). Quantifying the shelter capacity of coral reefs using photogrammetric   3D modeling: From colonies to reefscapes. Ecological Indicators, 121, 107151. https://doi.org/10.1016/j.ecolind.2020.107151\n\n\n\n\n\n","category":"constant"},{"location":"API/#ADRIA.metrics.coral_evenness","page":"ADRIA API","title":"ADRIA.metrics.coral_evenness","text":"coral_evenness(r_taxa_cover::AbstractArray{T})::Array{T} where {T<:Real}\ncoral_evenness(rs::ResultSet)::AbstractArray{T} where {T}\n\nCalculates evenness across functional coral groups in ADRIA as a diversity metric. Inverse Simpsons diversity indicator.\n\nReferences\n\nHill, M. O. (1973).  Diversity and Evenness: A Unifying Notation and Its Consequences. Ecology, 54(2), 427-432. https://doi.org/10.2307/1934352\n\n\n\n\n\n","category":"constant"},{"location":"API/#ADRIA.metrics.juvenile_indicator","page":"ADRIA API","title":"ADRIA.metrics.juvenile_indicator","text":"juvenile_indicator(X::AbstractArray{T}, coral_params::DataFrame, area::Vector{Float64}, k_area::Vector{Float64}) where {T<:Real}\njuvenile_indicator(rs::ResultSet)\n\nIndicator for juvenile density (0 - 1), where 1 indicates the maximum theoretical density for juveniles have been achieved.\n\nNotes\n\nMaximum density is 51.8 juveniles / m², where juveniles are defined as < 5cm diameter. See email correspondence from: Dr. A Thompson; to: Dr. K. Anthony Subject: RE: Max density of juvenile corals on the GBR Sent: Friday, 14 October 2022 2:58 PM\n\n\n\n\n\n","category":"constant"},{"location":"API/#ADRIA.metrics.reef_condition_index","page":"ADRIA API","title":"ADRIA.metrics.reef_condition_index","text":"reef_condition_index(rc::AbstractArray, evenness::AbstractArray, sv::AbstractArray, juves::AbstractArray)::AbstractArray\nreef_condition_index(rs)\n\nEstimates a Reef Condition Index (RCI) providing a single value that indicates the condition of a reef across four metrics:\n\ncoral cover\nevenness (coral diversity)\nshelter volume, and\nabundance of juveniles\n\nNotes\n\nJuveniles are made relative to maximum observed juvenile density (51.8/m²) See notes for juvenile_indicator()\n\nArguments\n\nrc : Relative coral cover across all groups\nevenness : Evenness across all coral groups\nsv : Shelter volume based on coral sizes and abundances\njuves : Abundance of coral juveniles < 5 cm diameter\n\nReturns\n\nNamedArray[timesteps ⋅ locations ⋅ scenarios]\n\n\n\n\n\n","category":"constant"},{"location":"API/#ADRIA.metrics.reef_fish_index","page":"ADRIA API","title":"ADRIA.metrics.reef_fish_index","text":"reef_fish_index(rc::AbstractArray)\nreef_fish_index(rs::ResultSet)\n\nThe Reef Fish Index (RFI) estimates fish biomass from relative coral cover.\n\nA linear regression (developed by Dr. R. Heneghan, Queensland University of Technology) is used to indicate the relationship between coral cover and fish biomass. The regression was developed with digitized data from Figures 4a and 6b in Graham & Nash (2013; see [1]).\n\nValues are provided ∈ [0, 1], where 1 indicates maximum fish biomass.\n\nNote: Coral cover here is relative to coral habitable area (k area).\n\nArguments\n\nrc : Relative cover\n\nReturns\n\nNamedArray[timesteps ⋅ locations ⋅ scenarios], values in kg/km²\n\nReferences\n\nGraham, N.A.J., Nash, K.L., 2013.\n\nThe importance of structural complexity in coral reef ecosystems. Coral Reefs 32, 315–326. https://doi.org/10.1007/s00338-012-0984-y\n\n\n\n\n\n","category":"constant"},{"location":"API/#ADRIA.metrics.reef_tourism_index","page":"ADRIA API","title":"ADRIA.metrics.reef_tourism_index","text":"reef_tourism_index(rc::AbstractArray, evenness::AbstractArray, sv::AbstractArray, juves::AbstractArray)::AbstractArray\nreef_tourism_index(rs::ResultSet)::AbstractArray\n\nEstimate tourism index.\n\nNote: This metric assumes all inputs (relative cover, evenness, shelter volume, coral juveniles) are scaled between 0 and 1. For evenness, shelter volume and coral juveniles, a value of 1 may represent a theoretical maximum.\n\nArguments\n\nrc : Relative coral cover across all groups\nevenness : Evenness across all coral groups\nsv : Shelter volume based on coral sizes and abundances\njuves : Abundance of coral juveniles < 5 cm diameter\n\n\n\n\n\n","category":"constant"},{"location":"API/#ADRIA.metrics.relative_cover","page":"ADRIA API","title":"ADRIA.metrics.relative_cover","text":"relative_cover(X::AbstractArray{<:Real})::AbstractArray{<:Real}\nrelative_cover(rs::ResultSet)::AbstractArray{<:Real}\n\nIndicate coral cover relative to available hard substrate (k area).\n\nArguments\n\nX : Matrix of raw model results\n\nReturns\n\nCoral cover [0 - 1], relative to available k area for a given location.\n\n\n\n\n\n","category":"constant"},{"location":"API/#ADRIA.metrics.relative_juveniles","page":"ADRIA API","title":"ADRIA.metrics.relative_juveniles","text":"relative_juveniles(X::AbstractArray{T})::AbstractArray{T} where {T}\nrelative_juveniles(rs::ResultSet)::AbstractArray\n\nJuvenile coral cover relative to total site area.\n\n\n\n\n\n","category":"constant"},{"location":"API/#ADRIA.metrics.relative_shelter_volume","page":"ADRIA API","title":"ADRIA.metrics.relative_shelter_volume","text":"_relative_shelter_volume(X::AbstractArray{T,3}, k_area::Vector{T}, inputs::DataFrame)::AbstractArray{T} where {T<:Real}\n_relative_shelter_volume(X::AbstractArray{T,3}, k_area::Vector{T}, inputs::DataFrameRow)::AbstractArray{T} where {T<:Real}\n_relative_shelter_volume(X::AbstractArray{T,3}, k_area::Vector{T}, inputs::NamedDimsArray)::NamedDimsArray where {T<:Real}\n_relative_shelter_volume(X::AbstractArray{T,4}, k_area::Vector{T}, inputs::DataFrame)::NamedDimsArray where {T<:Real}\n_relative_shelter_volume(X::AbstractArray{T,4}, k_area::Vector{T}, inputs::DataFrameRow)::NamedDimsArray where {T<:Real}\n_relative_shelter_volume(X::AbstractArray{T,4}, k_area::Vector{T}, inputs::NamedDimsArray)::NamedDimsArray where {T<:Real}\nrelative_shelter_volume(rs::ResultSet)\n\nProvide indication of shelter volume relative to theoretical maximum volume for the area covered by coral.\n\nThe metric applies log-log linear models developed by Urbina-Barreto et al., [1] which uses colony diameter and planar area (2D metrics) to estimate shelter volume (a 3D metric).\n\nRSV = begincases\nTASV  MSV  TASV  0 \n0  textotherwise\nendcases\n\nwhere TASV represents Total Absolute Shelter Volume and MSV represents the maximum shelter volume possible.\n\nArguments\n\nX : raw results\nk_area : area in m^2 for each site\ninputs : DataFrame of scenario inputs\n\nReturns\n\nShelter volume relative to a theoretical maximum volume for the available k area.\n\nReferences\n\nUrbina-Barreto, I., Chiroleu, F., Pinel, R., Fréchon, L., Mahamadaly, V.,   Elise, S., Kulbicki, M., Quod, J.-P., Dutrieux, E., Garnier, R.,   Henrich Bruggemann, J., Penin, L., & Adjeroud, M. (2021). Quantifying the shelter capacity of coral reefs using photogrammetric   3D modeling: From colonies to reefscapes. Ecological Indicators, 121, 107151. https://doi.org/10.1016/j.ecolind.2020.107151\n\n\n\n\n\n","category":"constant"},{"location":"API/#ADRIA.metrics.relative_taxa_cover","page":"ADRIA API","title":"ADRIA.metrics.relative_taxa_cover","text":"relative_taxa_cover(X::AbstractArray{T}, k_area::Vector{T}) where {T<:Real}\nrelative_taxa_cover(rs::ResultSet)\n\nResults grouped by taxa/species.\n\nTODO: Number of size classes is hard coded.\n\nArguments\n\nX : Raw model results for a single scenario\nk_area : the coral habitable area\narea : total location area\n\nReturns\n\nCoral cover, grouped by taxa for the given scenario, relative to location k area.\n\n\n\n\n\n","category":"constant"},{"location":"API/#ADRIA.metrics.scenario_absolute_juveniles","page":"ADRIA API","title":"ADRIA.metrics.scenario_absolute_juveniles","text":"scenario_absolute_juveniles(data::NamedDimsArray, coral_spec::DataFrame, k_area::AbstractVector{<:Real}; kwargs...)::AbstractArray{<:Real}\nscenario_absolute_juveniles(rs::ResultSet; kwargs...)::AbstractArray{<:Real}\n\nCalculate the mean absolute juvenile population for each scenario for the entire domain.\n\n\n\n\n\n","category":"constant"},{"location":"API/#ADRIA.metrics.scenario_asv","page":"ADRIA API","title":"ADRIA.metrics.scenario_asv","text":"scenario_asv(sv::NamedDimsArray; kwargs...)::AbstractArray{<:Real}\nscenario_asv(rs::ResultSet; kwargs...)::AbstractArray{<:Real}\n\nCalculate the mean absolute shelter volumes for each scenario for the entire domain.\n\n\n\n\n\n","category":"constant"},{"location":"API/#ADRIA.metrics.scenario_evenness","page":"ADRIA API","title":"ADRIA.metrics.scenario_evenness","text":"scenario_evenness(ev::NamedDimsArray; kwargs...)::AbstractArray{<:Real}\nscenario_evenness(rs::ResultSet; kwargs...)::AbstractArray{<:Real}\n\nCalculate the mean coral evenness for each scenario for the entire domain.\n\n\n\n\n\n","category":"constant"},{"location":"API/#ADRIA.metrics.scenario_juvenile_indicator","page":"ADRIA API","title":"ADRIA.metrics.scenario_juvenile_indicator","text":"scenario_juvenile_indicator(data::NamedDimsArray, coral_spec::DataFrame, k_area::AbstractVector{<:Real}; kwargs...)::AbstractArray{<:Real}\nscenario_juvenile_indicator(rs::ResultSet; kwargs...)::AbstractArray{<:Real}\n\nDetermine juvenile indicator ∈ [0, 1], where 1 indicates maximum mean juvenile density (51.8) has been achieved.\n\n\n\n\n\n","category":"constant"},{"location":"API/#ADRIA.metrics.scenario_rci","page":"ADRIA API","title":"ADRIA.metrics.scenario_rci","text":"scenario_rci(rci::NamedDimsArray, tac::NamedDimsArray; kwargs...)\nscenario_rci(rs::ResultSet; kwargs...)\n\nExtract the total populated area of locations with Reef Condition Index of \"Good\" or higher for each scenario for the entire domain.\n\n\n\n\n\n","category":"constant"},{"location":"API/#ADRIA.metrics.scenario_relative_cover","page":"ADRIA API","title":"ADRIA.metrics.scenario_relative_cover","text":"scenario_relative_cover(rs::ResultSet; kwargs...)::AbstractArray{<:Real}\n\nCalculate the mean relative coral cover for each scenario for the entire domain.\n\n\n\n\n\n","category":"constant"},{"location":"API/#ADRIA.metrics.scenario_relative_juveniles","page":"ADRIA API","title":"ADRIA.metrics.scenario_relative_juveniles","text":"scenario_relative_juveniles(data::NamedDimsArray, coral_spec::DataFrame, area::AbstractVector{<:Real}; kwargs...)::AbstractArray{<:Real}\n\nCalculate the mean relative juvenile population for each scenario for the entire domain.\n\n\n\n\n\n","category":"constant"},{"location":"API/#ADRIA.metrics.scenario_rfi","page":"ADRIA API","title":"ADRIA.metrics.scenario_rfi","text":"scenario_rfi(rfi::NamedDimsArray; kwargs...)\nscenario_rfi(rs::ResultSet; kwargs...)\n\nCalculate the mean Reef Fish Index (RFI) for each scenario for the entire domain.\n\n\n\n\n\n","category":"constant"},{"location":"API/#ADRIA.metrics.scenario_rsv","page":"ADRIA API","title":"ADRIA.metrics.scenario_rsv","text":"scenario_rsv(sv::NamedDimsArray; kwargs...)::AbstractArray{<:Real}\nscenario_rsv(rs::ResultSet; kwargs...)::AbstractArray{<:Real}\n\nCalculate the mean relative shelter volumes for each scenario for the entire domain.\n\n\n\n\n\n","category":"constant"},{"location":"API/#ADRIA.metrics.scenario_rti","page":"ADRIA API","title":"ADRIA.metrics.scenario_rti","text":"scenario_rti(rti::NamedDimsArray; kwargs...)\nscenario_rti(rs::ResultSet; kwargs...)\n\nCalculate the mean Reef Tourism Index (RTI) for each scenario for the entire domain.\n\n\n\n\n\n","category":"constant"},{"location":"API/#ADRIA.metrics.scenario_total_cover","page":"ADRIA API","title":"ADRIA.metrics.scenario_total_cover","text":"scenario_total_cover(rs::ResultSet; kwargs...)::AbstractArray{<:Real}\n\nCalculate the mean absolute coral for each scenario for the entire domain.\n\n\n\n\n\n","category":"constant"},{"location":"API/#ADRIA.metrics.total_absolute_cover","page":"ADRIA API","title":"ADRIA.metrics.total_absolute_cover","text":"total_absolute_cover(X::AbstractArray{<:Real}, k_area::Vector{<:Real})::AbstractArray{<:Real}\ntotal_absolute_cover(rs::ResultSet)::AbstractArray{<:Real}\n\nThe Total Absolute Coral Cover. Sum of proportional area taken up by all corals, multiplied by total site area.\n\nArguments\n\nX : Matrix of raw model results\nk_area : Site areas, with sites following the same order as given indicated in X.\n\nReturns\n\nAbsolute coral cover for a given location in m².\n\n\n\n\n\n","category":"constant"},{"location":"API/#ADRIA.metrics._collate_ranks-Tuple{ADRIA.ResultSet, Any}","page":"ADRIA API","title":"ADRIA.metrics._collate_ranks","text":"_collate_ranks(rs, selected)\n\nCollates ranks into seed/shade ranking results into a common structure.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics._colony_Lcm2_to_m3m2-Tuple{NamedDims.NamedDimsArray}","page":"ADRIA API","title":"ADRIA.metrics._colony_Lcm2_to_m3m2","text":"_colony_Lcm2_to_m3_m2(inputs::DataFrame)::Tuple\n\nHelper function to convert coral colony values from Litres/cm² to m³/m²\n\nArguments\n\ninputs : Scenario values for the simulation\n\nReturns\n\nTuple : Assumed colony volume (m³/m²) for each species/size class, theoretical maximum for each species/size class\n\nReferences\n\nAston Eoghan A., Duce Stephanie, Hoey Andrew S., Ferrari Renata (2022).  A Protocol for Extracting Structural Metrics From 3D Reconstructions of Corals.  Frontiers in Marine Science, 9.  https://doi.org/10.3389/fmars.2022.854395\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics._get_ranks-Tuple{ADRIA.ResultSet, Int64}","page":"ADRIA API","title":"ADRIA.metrics._get_ranks","text":"_get_ranks(rs::ResultSet, intervention::Int64; kwargs...)\n\nExtracts results for a specific intervention (seeding [1] or shading [2])\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics._max_juvenile_area","page":"ADRIA API","title":"ADRIA.metrics._max_juvenile_area","text":"_max_juvenile_area(coral_params::DataFrame, max_juv_density::Float64=51.8)\n\nCalculate the maximum possible area that can be covered by juveniles for a given m².\n\n\n\n\n\n","category":"function"},{"location":"API/#ADRIA.metrics._shelter_species_loop!-Union{Tuple{V}, Tuple{T1}, Tuple{T1, T1, Int64, V, V}} where {T1<:NamedDims.NamedDimsArray{(:timesteps, :species, :sites), Float64, 3, Array{Float64, 3}}, V<:(AbstractVector{<:Float64})}","page":"ADRIA API","title":"ADRIA.metrics._shelter_species_loop!","text":"_shelter_species_loop!(X::T1, ASV::T1, nspecies::Int64, colony_vol_m3_per_m2::V, k_area::V) where {T1<:NamedDims.NamedDimsArray{(:timesteps, :species, :sites),Float64,3,Array{Float64,3}},V<:AbstractVector{<:Float64}}\n\nHelper method to calculate absolute shelter volume metric across each species/size class for a given scenario.\n\nArguments\n\nX : raw results (proportional coral cover relative to full site area)\nASV : matrix to hold shelter volume results\nnspecies : number of species (taxa and size classes) considered\nscen : scenario number to calculate metric for\ncolony_vol_m3_per_m2 : estimated cubic volume per m² of coverage for each species/size class (36)\nk_area : habitable area of site in m²\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics._shelter_species_loop-Union{Tuple{F}, Tuple{T1}, Tuple{AbstractArray{T1, 3}, Int64, Array{F}, Array{F}, Array{F}}} where {T1<:Real, F<:Float64}","page":"ADRIA API","title":"ADRIA.metrics._shelter_species_loop","text":"_shelter_species_loop(X, nspecies::Int64, scen::Int64, colony_vol_m3_per_m2, max_colony_vol_m3_per_m2, site_area)\n\nHelper method to calculate relative shelter volume metric across each species/size class for a given scenario.\n\nNote: Species dimension is an amalgamation of taxa and size class. e.g., X[species=1:6] is Taxa 1, size classes 1-6; X[species=7:12] is Taxa 2, size class 1-6, etc.\n\nArguments\n\nX : raw results (proportional coral cover relative to full site area)\nn_species : number of species (taxa and size classes) considered\nscen : scenario number to calculate metric for\ncolony_vol_m3_per_m2 : estimated cubic volume per m² of coverage for each species/size class (36)\nmax_colony_vol_m3_per_m2 : theoretical maximum volume per m² of coverage for each taxa (6)\nsite_area : total area of site in m²\nk_area : habitable area of site in m² (i.e., k area)\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.call_metric-Tuple{Union{Function, ADRIA.metrics.Metric}, NamedDims.NamedDimsArray, Vararg{Any}}","page":"ADRIA API","title":"ADRIA.metrics.call_metric","text":"call_metric(metric, data, args...; timesteps=(:), species=(:), sites=(:), scens=(:))\n\nConvenience method that slices the data in the specified manner.\n\nArguments\n\nmetric : Function, the metric function to apply to \"raw\" data.\ndata : NamedDimsArray, data to pass into metric\nargs : Additional positional arguments to pass into metric\ndims : dummy keyword argument, not used but defined to allow use with other methods\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.dims-Tuple{ADRIA.metrics.Metric}","page":"ADRIA API","title":"ADRIA.metrics.dims","text":"dims(m::Metric)::Tuple\n\nGet dimension names for a given outcome/metric.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.dominates-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}}","page":"ADRIA API","title":"ADRIA.metrics.dominates","text":"dominates(x::Vector{<:Real}, y::Vector{<:Real})::Vector\n\nAdapted from: https://discourse.julialang.org/t/fast-optimized-non-dominated-sorting-algorithms/86793/7\n\nOriginal function name is dominates2()\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.loc_trajectory-Union{Tuple{A}, Tuple{N}, Tuple{T}, Tuple{D}, Tuple{Any, NamedDims.NamedDimsArray{D, T, N, A}}} where {D, T, N, A}","page":"ADRIA API","title":"ADRIA.metrics.loc_trajectory","text":"loc_trajectory(metric, data::NamedDimsArray{D,T,N,A})::NamedDimsArray where {D,T,N,A}\n\nAlias for summarize(data, [:scenarios], metric). Collate trajectory for each location.\n\nExamples\n\nusing Statistics\n\nrs = ADRIA.load_results(\"some results\")\ntac = ADRIA.metrics.total_absolute_cover(rs)\n\n# Get median trajectory for each site\nADRIA.metrics.loc_trajectory(median, tac)\n# 2-dimensional NamedDimsArray(KeyedArray(...)) with keys:\n# ↓   timesteps ∈ 75-element Vector{Any}\n# →   sites ∈ 216-element Vector{Any}\n# And data, 75×216 Matrix{Float32}:\n\n# Get upper 95% CI for each site\nADRIA.metrics.loc_trajectory(x -> quantile(x, 0.975), tac)\n# 2-dimensional NamedDimsArray(KeyedArray(...)) with keys:\n# ↓   timesteps ∈ 75-element Vector{Any}\n# →   sites ∈ 216-element Vector{Any}\n# And data, 75×216 Matrix{Float32}:\n\nArguments\n\nmetric : Any function (nominally from the Statistics package) to be applied to data\ndata : Data set to apply metric to\n\nReturns\n\n2D array of T  S, where T is total number of time steps and S is number of sites\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.metric_label-Tuple{ADRIA.metrics.Metric}","page":"ADRIA API","title":"ADRIA.metrics.metric_label","text":"metric_label(m::Metric)::String\nmetric_label(f::Function, unit::String)\n\nReturn name of metric in the format: \"Title Case [Unit]\", suitable for use as a label.\n\nExample\n\nm_label = metric_label(scenario_total_cover)\n# \"Scenario Total Cover [m²]\"\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.nds","page":"ADRIA API","title":"ADRIA.metrics.nds","text":"nds(X::AbstractArray{<:Real}, dist::Int64=0)::Vector{Vector{<:Int}}\n\nNaive n-dimensional non-dominated sorting.\n\nAdapted from: https://discourse.julialang.org/t/fast-optimized-non-dominated-sorting-algorithms/86793/7\n\nOriginal function name is nds4()\n\nArguments\n\nX : outcomes, where rows are scenarios and columns are metric results. dist : distance from front, where 0 is on the frontier.\n\nReturns\n\nVector of Vectors with row indices for each dist from frontier, where 0 is on the frontier.\n\n\n\n\n\n","category":"function"},{"location":"API/#ADRIA.metrics.per_loc-Union{Tuple{A}, Tuple{N}, Tuple{T}, Tuple{D}, Tuple{Any, NamedDims.NamedDimsArray{D, T, N, A}}} where {D, T, N, A}","page":"ADRIA API","title":"ADRIA.metrics.per_loc","text":"per_loc(metric, data::NamedDimsArray{D,T,N,A})::NamedDimsArray where {D,T,N,A}\n\nAlias for summarize(data, [:scenarios, :timesteps], metric). Get metric results applied to the location-level at indicated time (or across timesteps).\n\nArguments\n\nmetric : Any function (nominally from the Statistics package) to be applied to data\ndata : Data set to apply metric to\ntimesteps : timesteps to apply metric across\n\nReturns\n\nNamed Vector of N elements, where N is the number of sites.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.scenario_outcomes-Tuple{ADRIA.ResultSet, Vector{<:ADRIA.metrics.Metric}}","page":"ADRIA API","title":"ADRIA.metrics.scenario_outcomes","text":"scenario_outcomes(rs::ResultSet, metrics::Vector{Metric})::NamedDimsArray\n\nGet outcomes for a given list of metrics and a result set.\n\nArguments\n\nrs : ResultSet\nmetrics : Vector of scenario Metrics (the ones that start with scenario_)\n\nReturns\n\nNamedDimsArray with (:timesteps, :scenarios, :outcomes)\n\nExamples\n\nmetrics::Vector{ADRIA.metrics.Metric} = [\n    ADRIA.metrics.scenario_total_cover,\n    ADRIA.metrics.scenario_asv,\n    ADRIA.metrics.scenario_absolute_juveniles,\n]\n\n# 3-dimensional Array of outcomes\noutcomes = ADRIA.metrics.scenario_outcomes(rs, metrics)\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.scenario_trajectory-Tuple{AbstractArray}","page":"ADRIA API","title":"ADRIA.metrics.scenario_trajectory","text":"scenario_trajectory(data::AbstractArray; metric=mean)\n\nProduce scenario trajectories using the provided metric/aggregation function.\n\nArguments\n\ndata : Results to aggregate\nmetric : Function or Callable used to summarize data\n\nReturns\n\nMatrix[timesteps ⋅ scenarios]\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.seed_ranks-Tuple{ADRIA.ResultSet}","page":"ADRIA API","title":"ADRIA.metrics.seed_ranks","text":"seed_ranks(rs::ResultSet; kwargs...)\n\nArguments\n\nrs : ResultSet\nkwargs : named dimensions to slice across\n\nReturns\n\nNamedDimsArray[timesteps, sites, scenarios]\n\nExample\n\nADRIA.metrics.seed_ranks(rs; timesteps=1:10, scenarios=3:5)\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.shade_ranks-Tuple{ADRIA.ResultSet}","page":"ADRIA API","title":"ADRIA.metrics.shade_ranks","text":"shade_ranks(rs::ResultSet; kwargs...)\n\nArguments\n\nrs : ResultSet\nkwargs : named dimensions to slice across\n\nReturns\n\nNamedDimsArray[timesteps, sites, scenarios]\n\nExample\n\nADRIA.metrics.shade_ranks(rs; timesteps=1:10, scenarios=3:5)\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.slice_results-Tuple{NamedDims.NamedDimsArray}","page":"ADRIA API","title":"ADRIA.metrics.slice_results","text":"slice_results(data::NamedDimsArray; timesteps=(:), species=(:), sites=(:), scenarios=(:))\n\nSlice data as indicated. Dimensions not found in target data are ignored.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.summarize-Union{Tuple{A}, Tuple{N}, Tuple{T}, Tuple{D}, Tuple{NamedDims.NamedDimsArray{D, T, N, A}, Vector{Symbol}, Function}} where {D, T, N, A}","page":"ADRIA API","title":"ADRIA.metrics.summarize","text":"summarize(data::NamedDimsArray{<:Real}, alongs_axis::Vector{Symbol}, metric::Function)::NamedDimsArray{<:Real}\nsummarize(data::NamedDimsArray{<:Real}, alongs_axis::Vector{Symbol}, metric::Function, timesteps::Union{UnitRange,Vector{Int64},BitVector})::NamedDimsArray{<:Real}\n\nApply summary metric along some axis of a data set across some or all timesteps.\n\nArguments\n\ndata : Data set to apply metric to.\nalongs_axis : which axis will be replaced with (:) when slicing.\nmetric : Any function (nominally from the Statistics package) to be applied to data.\ntimesteps : timesteps to apply metric across.\n\nReturns\n\nNamedDimsArray with summary metric for the remaining axis.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.summarize_absolute_shelter_volume-Tuple{NamedDims.NamedDimsArray}","page":"ADRIA API","title":"ADRIA.metrics.summarize_absolute_shelter_volume","text":"summarize_absolute_shelter_volume(sv::AbstractArray{<:Real}, kwargs...)::Dict{Symbol,AbstractArray{<:Real}}\nsummarize_absolute_shelter_volume(rs::ResultSet, kwargs...)::Dict{Symbol,AbstractArray{<:Real}}\n\nCalculate summarized coral evenness.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.summarize_coral_evenness-Tuple{NamedDims.NamedDimsArray}","page":"ADRIA API","title":"ADRIA.metrics.summarize_coral_evenness","text":"summarize_coral_evenness(raw::AbstractArray{<:Real}, kwargs...)::Dict{Symbol,AbstractArray{<:Real}}\nsummarize_coral_evenness(rs::ResultSet, kwargs...)::Dict{Symbol,AbstractArray{<:Real}}\n\nCalculate summarized coral evenness.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.summarize_raw-Tuple{NamedDims.NamedDimsArray}","page":"ADRIA API","title":"ADRIA.metrics.summarize_raw","text":"summarize_raw(data::NamedDimsArray; kwargs...)::Dict{Symbol,AbstractArray{<:Real}}\n\nSummarize raw data, aggregating the specified dimensions (e.g., timesteps, scenarios, etc.) and collapsing given dims.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.summarize_relative_cover-Tuple{NamedDims.NamedDimsArray}","page":"ADRIA API","title":"ADRIA.metrics.summarize_relative_cover","text":"summarize_relative_cover(rc::AbstractArray{<:Real}, kwargs...)::Dict{Symbol,AbstractArray{<:Real}}\nsummarize_relative_cover(rs::ResultSet, kwargs...)::Dict{Symbol,AbstractArray{<:Real}}\n\nCalculate summarized relative cover.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.summarize_relative_shelter_volume-Tuple{NamedDims.NamedDimsArray}","page":"ADRIA API","title":"ADRIA.metrics.summarize_relative_shelter_volume","text":"summarize_relative_shelter_volume(sv::AbstractArray{<:Real}, kwargs...)::Dict{Symbol,AbstractArray{<:Real}}\nsummarize_relative_shelter_volume(rs::ResultSet, kwargs...)::Dict{Symbol,AbstractArray{<:Real}}\n\nCalculate summarized coral evenness.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.summarize_total_cover-Tuple{NamedDims.NamedDimsArray, AbstractArray{<:Real}}","page":"ADRIA API","title":"ADRIA.metrics.summarize_total_cover","text":"summarize_total_cover(raw::AbstractArray{<:Real}, areas::AbstractArray{<:Real}; kwargs...)::Dict{Symbol,AbstractArray{<:Real}}\nsummarize_total_cover(rs::ResultSet; kwargs...)::Dict{Symbol,AbstractArray{<:Real}}\n\nCalculate summarized total absolute cover.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.to_string-Tuple{ADRIA.metrics.Metric}","page":"ADRIA API","title":"ADRIA.metrics.to_string","text":"to_string(m::Metric)::String\n\nGet name of metric as a string.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.to_symbol-Tuple{ADRIA.metrics.Metric}","page":"ADRIA API","title":"ADRIA.metrics.to_symbol","text":"to_symbol(m::Metric)::String\n\nGet name of metric as a symbol.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.top_N_sites-Tuple{ADRIA.ResultSet, Int64}","page":"ADRIA API","title":"ADRIA.metrics.top_N_sites","text":"top_N_sites(rs::ResultSet; N::Int64; metric::relative_cover)\ntop_N_sites(data::AbstractArray{Real}, N::Int64; stat=mean)\n\nReturn the top N sites according to the provided metric (defaulting to mean of relative_cover).\n\nArguments\n\nrs : ResultSet\nN : No. of best performing sites to be selected\nmetric : metric to use to order sites from best to worst,          must take ResultSet as input\nstat : summary statistic to use for comparison (default: mean)\n\nReturns\n\nNamedDimsArray[:scenarios,:siteids], where `siteids` indicates order of site ranking as well.\n\nExample\n\nADRIA.metrics.top_N_sites(rs, 5)\nADRIA.metrics.top_N_sites(rs, 5; metric=ADRIA.metric.relative_cover)\nADRIA.metrics.top_N_sites(rs, 5; metric=ADRIA.metric.relative_cover, stat=median)\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.top_n_seeded_sites-Tuple{ADRIA.ResultSet, Int64}","page":"ADRIA API","title":"ADRIA.metrics.top_n_seeded_sites","text":"top_n_seeded_sites(rs::ResultSet, n::Int64; kwargs...)\n\nGet the top n seeded sites over time by their unique site id. Lower rank values are better (e.g., 1 = first choice)\n\nArguments\n\nrs : ResultSet\nn : n sites to retrieve\nkwargs : dimensions to slice across\n\nReturns\n\nNamedDimsArray[sites, [Site Index, Unique ID, Rank], scenarios]\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.trajectory_heatmap-Tuple{NamedDims.NamedDimsArray}","page":"ADRIA API","title":"ADRIA.metrics.trajectory_heatmap","text":"trajectory_heatmap(data::Matrix{Float64})::Tuple{Vector{Float64}, Vector{Float64}, Matrix{Int64}}\n\nEstimate heatmap of trajectories from a 2D dataset.\n\nArguments\n\ndata : An N*D matrix where N is time steps and D is the scenario outcome for the given timestep in N\n\nReturns\n\nOnlineStats.HeatMap\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.trajectory_heatmap_data-Tuple{NamedDims.NamedDimsArray}","page":"ADRIA API","title":"ADRIA.metrics.trajectory_heatmap_data","text":"trajectory_heatmap_data(data::Matrix{Float64})::Tuple{Vector{Float64}, Vector{Float64}, Matrix{Int64}}\n\nEstimate heatmap of trajectories from a 2D dataset.\n\nArguments\n\ndata : An N*D matrix where N is time steps and D is the scenario outcome for the given timestep in N\n\nReturns\n\nTuple of xedges, yedges, and bi-dimensional histogram matrix\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.ndims-Tuple{ADRIA.metrics.Metric}","page":"ADRIA API","title":"Base.ndims","text":"ndims(m::Metric)::Int64\n\nInfer the number of dimensions for a given outcome/metric.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.metrics.Metric-Tuple{Any, Vararg{Any}}","page":"ADRIA API","title":"ADRIA.metrics.Metric","text":"(f::Metric)(raw, args...; kwargs...)\n(f::Metric)(rs::ResultSet, args...; kwargs...)\n\nMakes Metric types callable with arbitary arguments that are passed to associated function.\n\n\n\n\n\n","category":"method"},{"location":"API/#Performance-indicators","page":"ADRIA API","title":"Performance indicators","text":"","category":"section"},{"location":"API/","page":"ADRIA API","title":"ADRIA API","text":"Modules = [ADRIA.performance]\nOrder   = [:function, :type]","category":"page"},{"location":"API/#ADRIA.performance.RMSE-Tuple{Any, Any}","page":"ADRIA API","title":"ADRIA.performance.RMSE","text":"Root Mean Square Error\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.performance.environmental_diversity-Tuple{Any, Any}","page":"ADRIA API","title":"ADRIA.performance.environmental_diversity","text":"environmental_diversity(ms, inputs_i)\n\nObtain an indication of environmental factor diversity for a scenario set. Higher values indicate a greater of mix of environmental conditions were experienced between scenarios.\n\nThis is referred to as E.\n\nArguments\n\nms : model spec\ninputs_i : inputs used for scenarios of interest\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.performance.gmd-Tuple{AbstractVector{<:Real}}","page":"ADRIA API","title":"ADRIA.performance.gmd","text":"gmd(vals::AbstractVector{<:Real})::Float64\ngmd(vals::AbstractMatrix{<:Real})\n\nGini's Mean Difference.\n\nThe absolute mean of all pairwise distances between elements in a given set.\n\nReferences\n\nLa Haye, R., & Zizler, P. (2019). The Gini mean difference and variance. METRON, 77(1), 43-52. https://doi.org/10.1007/s40300-019-00149-2\nYitzhaki, S. (2003). Gini's Mean difference: A superior measure of variability for non-normal   distributions. Metron - International Journal of Statistics, LXI(2), 285-316. https://ideas.repec.org/a/mtn/ancoec/030208.html\nKashif, M., Aslam, M., Al-Marshadi, A. H., & Jun, C.-H. (2016). Capability Indices for Non-Normal Distribution Using Gini's Mean Difference as Measure of Variability. IEEE Access, 4, 7322-7330. https://doi.org/10.1109/ACCESS.2016.2620241\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.performance.intervention_diversity-Tuple{Any, Any}","page":"ADRIA API","title":"ADRIA.performance.intervention_diversity","text":"intervention_diversity(ms, inputs_i)\n\nObtain an indication of intervention diversity for a scenario. Higher values indicate a greater of mix of interventions options were applied.\n\nThis is referred to as D.\n\nArguments\n\nms : model spec\ninputs_i : inputs used for scenarios of interest\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.performance.intervention_effort-Tuple{Any, Any, Any}","page":"ADRIA API","title":"ADRIA.performance.intervention_effort","text":"intervention_effort(ms, inputs_i)\n\nObtain an indication of intervention effort for each scenario and intervention type. This is referred to as F.\n\nArguments\n\nms : model spec\ninputs_i : inputs used for scenarios of interest\n\nReturns\n\nMatrix of s * 8, where s is the number of scenarios and columns are: N_seed_TA, N_seed_CA, N_seed_SM, fogging, SRM, seed_years, shade_years, fog_years\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.performance.normalize-Tuple{AbstractArray{<:Real}}","page":"ADRIA API","title":"ADRIA.performance.normalize","text":"normalize(vals::AbstractArray{<:Real})\n\nNormalize values using feature scaling such that values are bound between 0 and 1, where 1 is equivalent to the maximum value found.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.performance.probability-Tuple{AbstractArray{<:Real}}","page":"ADRIA API","title":"ADRIA.performance.probability","text":"probability(vals::AbstractArray{<:Real})\n\nCalculate probability of individual trajectories, given a scenario ensemble S.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.performance.temporal_variability-Tuple{AbstractVector{<:Real}}","page":"ADRIA API","title":"ADRIA.performance.temporal_variability","text":"temporal_variability(x::AbstractVector{<:Real})\ntemporal_variability(x::AbstractArray{<:Real, 2})\ntemporal_variability(x::AbstractArray{<:Real}, func_or_data...)\n\nThe V meta-metric.\n\nAs a meta-metric, it can be applied to any combination of metrics (including itself), assuming x is bound between 0 and 1. If this is not the case, consider normalizing values first.\n\nExamples\n\n# Apply V to a time series\njulia> temporal_variability(rand(50))\n\n# Apply V to an ensemble of time series\njulia> x = rand(50, 200)\njulia> temporal_variability(x)\n\n# Create and apply a modified V metric to an ensemble of time series.\n# Where the argument is an array and not a function, the data is used directly\n# and so it is assumed all matrices are of the same size and shape.\njulia> temporal_variability(x, temporal_variabilty, temporal_variability(P(x)))\njulia> temporal_variability(x, temporal_variabilty, P(x), D(x), E(x))\n\n\n\n\n\n","category":"method"},{"location":"API/#Sensitivity","page":"ADRIA API","title":"Sensitivity","text":"","category":"section"},{"location":"API/","page":"ADRIA API","title":"ADRIA API","text":"Modules = [ADRIA.sensitivity]\nOrder   = [:function, :type]","category":"page"},{"location":"API/#ADRIA.sensitivity._category_bins-Tuple{Int64, DataFrames.DataFrame}","page":"ADRIA API","title":"ADRIA.sensitivity._category_bins","text":"_category_bins(S::Int64, foi_spec::DataFrame)\n\nGet number of bins for categorical variables.\n\nArguments\n\nS : Number of bins\nfoi_spec : Model specification for factors of interest\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.sensitivity._get_cat_quantile-Tuple{DataFrames.DataFrame, Symbol, Vector{Float64}}","page":"ADRIA API","title":"ADRIA.sensitivity._get_cat_quantile","text":"_get_cat_quantile(foi_spec::DataFrame, factor_name::Symbol, steps::Vector{Float64})\n\nGet quantile value for a given categorical variable.\n\nArguments\n\nfoi_spec : Model specification for factors of interest\nfactor_name : Contains true where the factor is categorical and false otherwise\nsteps : Number of steps for defining bins\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.sensitivity._get_factor_spec-Tuple{DataFrames.DataFrame, Vector{Symbol}}","page":"ADRIA API","title":"ADRIA.sensitivity._get_factor_spec","text":"_get_factor_spec(model_spec::DataFrame, factors::Vector{Symbol})\n\nGet model spec for specified factors.\n\nArguments\n\nmodel_spec : Model specification, as extracted by ADRIA.model_spec(domain) or from a ResultSet\nfactors : Factors considered for sensitivity analysis\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.sensitivity.convergence-Tuple{DataFrames.DataFrame, NamedDims.NamedDimsArray, Vector{Symbol}}","page":"ADRIA API","title":"ADRIA.sensitivity.convergence","text":"convergence(X::DataFrame, y::NamedDimsArray, target_factors::Vector{Symbol}; n_steps::Int64=10)::NamedDimsArray\nconvergence(rs::ResultSet, X::DataFrame, y::NamedDimsArray, components::Vector{String}; n_steps::Int64=10)::NamedDimsArray\n\nCalculates the PAWN sensitivity index for an increasing number of scenarios where the maximum is the total number of scenarios in scens. Number of scenario subsets determined by N_steps. Can be calculated for individual factors or aggregated over factors for specified model components.\n\nArguments\n\nrs : Result set (only needed if aggregating over model components).\nX : Model inputs\ny : Model outputs\ntarget_factors : Names of target factors represented by columns in X.\ncomponents : Names of model components to aggregate over (e.g. [:Intervention, :Criteria]).\nn_steps : Number of steps to cut the total number of scenarios into.\n\nReturns\n\nNamedDimsArray, of min, lower bound, mean, median, upper bound, max, std, and cv summary statistics for an increasing number of scenarios.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.sensitivity.ks_statistic-Tuple{HypothesisTests.ApproximateKSTest}","page":"ADRIA API","title":"ADRIA.sensitivity.ks_statistic","text":"ks_statistic(ks)\n\nCalculate the Kolmogorov-Smirnov test statistic.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.sensitivity.outcome_map-Tuple{DataFrames.DataFrame, AbstractVecOrMat{<:Real}, Union{Function, BitVector, Vector{Int64}}, Vector{Symbol}, DataFrames.DataFrame}","page":"ADRIA API","title":"ADRIA.sensitivity.outcome_map","text":"outcome_map(X::DataFrame, y::AbstractVecOrMat, rule, target_factors::Vector; S::Int=20, n_boot::Int=100, conf::Float64=0.95)::NamedDimsArray\n\nMap normalized outcomes (defined by rule) to factor values discretized into S bins.\n\nProduces a matrix indicating the range of (normalized) outcomes across factor space for each dimension (the model inputs). This is similar to a Regional Sensitivity Analysis, except that the model outputs are examined directly as opposed to a measure of sensitivity.\n\nNote:\n\ny is normalized on a per-column basis prior to the analysis\nEmpty areas of factor space (those that do not have any desired outcomes) will be assigned NaN\n\nArguments\n\nX : scenario specification\ny : Vector or Matrix of outcomes corresponding to scenarios in X\nrule : a callable defining a \"desirable\" scenario outcome\ntarget_factors : list of factors of interest to perform analyses on\nS : number of slices of factor space. Higher values equate to finer granularity\nn_boot : number of bootstraps (default: 100)\nconf : confidence interval (default: 0.95)\n\nReturns\n\n3-dimensional NamedDimsArray, of shape S ⋅ D ⋅ 3, where:\n\nS\nis the slices,\nD\nis the number of dimensions, with\nboostrapped mean (dim 1) and the lower/upper 95% confidence interval (dims 2 and 3).\n\nExamples\n\n# Get metric of interest\nmu_tac = vec(mean(ADRIA.metrics.scenario_total_cover(rs), dims=:timesteps))\n\n# Factors of interest\nfoi = [:SRM, :fogging, :a_adapt]\n\n# Find scenarios where all metrics are above their median\nrule = y -> all(y .> 0.5)\n\n# Map input values where to their outcomes\nADRIA.sensitivity.outcome_map(X, y, rule, foi; S=20, n_boot=100, conf=0.95)\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.sensitivity.pawn-Tuple{AbstractMatrix{<:Real}, AbstractVector{<:Real}, Vector{String}}","page":"ADRIA API","title":"ADRIA.sensitivity.pawn","text":"pawn(rs::ResultSet, y::Union{NamedDimsArray,AbstractVector{<:Real}}; S::Int64=10)::NamedDimsArray\npawn(X::AbstractMatrix{<:Real}, y::AbstractVector{<:Real}, factor_names::Vector{String}; S::Int64=10)::NamedDimsArray\npawn(X::DataFrame, y::AbstractVector{<:Real}; S::Int64=10)::NamedDimsArray\npawn(X::NamedDimsArray, y::Union{NamedDimsArray,AbstractVector{<:Real}}; S::Int64=10)::NamedDimsArray\npawn(X::Union{DataFrame,AbstractMatrix{<:Real}}, y::AbstractMatrix{<:Real}; S::Int64=10)::NamedDimsArray\n\nCalculates the PAWN sensitivity index.\n\nThe PAWN method (by Pianosi and Wagener) is a moment-independent approach to Global Sensitivity Analysis. Outputs are characterized by their Cumulative Distribution Function (CDF), quantifying the variation in the output distribution after conditioning an input over \"slices\" (S) - the conditioning intervals. If both distributions coincide at all slices (i.e., the distributions are similar or identical), then the factor is deemed non-influential.\n\nThis implementation applies the Kolmogorov-Smirnov test as the distance measure and returns summary statistics (min, lower bound, mean, median, upper bound, max, std, and cv) over the slices.\n\nArguments\n\nrs : ResultSet\nX : Model inputs\ny : Model outputs\nfactor_names : Names of each factor represented by columns in X\nS : Number of slides (default: 10)\n\nReturns\n\nNamedDimsArray, of min, mean, lower bound, median, upper bound, max, std, and cv summary statistics.\n\nExamples\n\ndom = ADRIA.load_domain(\"example_domain\")\nscens = ADRIA.sample(dom, 128)\nrs = ADRIA.run_scenarios(dom, scens, \"45\")\n\n# Get mean coral cover over time and locations\nμ_tac = mean(ADRIA.metrics.scenario_total_cover(rs), dims=:timesteps)\n\nADRIA.sensitivity.pawn(rs, μ_tac)\n\nReferences\n\nPianosi, F., Wagener, T., 2018. Distribution-based sensitivity analysis from a generic input-output sample. Environmental Modelling & Software 108, 197-207. https://doi.org/10.1016/j.envsoft.2018.07.019\nBaroni, G., Francke, T., 2020. GSA-cvd Combining variance- and distribution-based global sensitivity analysis https://github.com/baronig/GSA-cvd\nPuy, A., Lo Piano, S., & Saltelli, A. 2020. A sensitivity analysis of the PAWN sensitivity index. Environmental Modelling & Software, 127, 104679. https://doi.org/10.1016/j.envsoft.2020.104679\nhttps://github.com/SAFEtoolbox/Miscellaneous/blob/main/ReviewofPuy_2020.pdf\n\nExtended help\n\nPianosi and Wagener have made public their review responding to a critique of their method by Puy et al., (2020). A key criticism by Puy et al. was that the PAWN method is sensitive to its tuning parameters and thus may produce biased results. The tuning parameters referred to are the number of samples (N) and the number of conditioning points - n in Puy et al., but denoted as S here.\n\nPuy et al., found that the ratio of N (number of samples) to S has to be sufficiently high (NS  80) to avoid biased results. Pianosi and Wagener point out this requirement is not particularly difficult to meet. Using the recommended value (S = 10), a sample of 1024 runs (small for purposes of Global Sensitivity Analysis) meets this requirement (102410 = 1024). Additionally, lower values of NS is more an indication of faulty experimental design moreso than any deficiency of the PAWN method.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.sensitivity.rsa-Tuple{DataFrames.DataFrame, AbstractVector{<:Real}, DataFrames.DataFrame}","page":"ADRIA API","title":"ADRIA.sensitivity.rsa","text":"rsa(X::DataFrame, y::Vector{<:Real}, model_spec::DataFrame; S::Int64=10)::NamedDimsArray\nrsa(rs::ResultSet, y::AbstractVector{<:Real}, factors::Vector{Symbol}; S::Int64=10)::NamedDimsArray\nrsa(rs::ResultSet, y::AbstractArray{<:Real}; S::Int64=10)::NamedDimsArray\n\nPerform Regional Sensitivity Analysis.\n\nRegional Sensitivity Analysis is a Monte Carlo Filtering approach which aims to identify which (group of) factors drive model outputs within or outside of a specified bound. Outputs which fall inside the bounds are regarded as \"behavioral\", whereas those outside are \"non-behavioral\". The distribution of behavioral/non-behavioral subsets are compared for each factor. If the subsets are not similar, then the factor is influential. The sensitivity index is simply the maximum distance between the two distributions, with larger values indicating greater sensitivity.\n\nThe implemented approach slices factor space into S bins and iteratively assesses behavioral (samples within the bin) and non-behavioral (out of bin samples) subsets with the non-parametric k-sample Anderson-Darling test. Larger values indicate greater dissimilarity (thus, sensitivity). The Anderson-Darling test places more weight on the tails compared to the Kolmogorov-Smirnov test.\n\nRSA can indicate where in factor space model sensitivities may be, and contributes to a Value-of-Information (VoI) analysis.\n\nIncreasing the value of S increases the granularity of the analysis, but necessitates larger sample sizes.\n\nNote: Values of type missing indicate a lack of samples in the region.\n\nArguments\n\nrs : ResultSet\nX : scenario specification\ny : scenario outcomes\nmodel_spec : Model specification, as extracted by ADRIA.model_spec(domain) or from a ResultSet\nfactors : Specific model factors to examine\nS : number of bins to slice factor space into (default: 10)\n\nReturns\n\nNamedDimsArray, [bin values, factors]\n\nExamples\n\nADRIA.sensitivity.rsa(X, y; S=10)\n\nReferences\n\nPianosi, F., K. Beven, J. Freer, J. W. Hall, J. Rougier, D. B. Stephenson, and T. Wagener. 2016. Sensitivity analysis of environmental models: A systematic review with practical workflow. Environmental Modelling & Software 79:214-232. https://dx.doi.org/10.1016/j.envsoft.2016.02.008\nSaltelli, A., M. Ratto, T. Andres, F. Campolongo, J. Cariboni, D. Gatelli, M. Saisana, and S. Tarantola. 2008. Global Sensitivity Analysis: The Primer. Wiley, West Sussex, U.K. https://dx.doi.org/10.1002/9780470725184 Accessible at: http://www.andreasaltelli.eu/file/repository/PrimerCorrected2022.pdf\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.sensitivity.tsa-Tuple{DataFrames.DataFrame, AbstractMatrix{<:Real}}","page":"ADRIA API","title":"ADRIA.sensitivity.tsa","text":"tsa(X::DataFrame, y::AbstractMatrix)::NamedDimsArray\n\nPerform Temporal (or time-varying) Sensitivity Analysis using the PAWN sensitivity index.\n\nThe sensitivity index value for time t is inclusive of all time steps prior to t. Alternate approaches use a moving window, or only data for time t.\n\nExamples\n\nrs = ADRIA.load_results(\"a ResultSet of interest\")\n\n# Get scenario outcomes over time (shape: `time ⋅ scenarios`)\ny_tac = ADRIA.metrics.scenario_total_cover(rs)\n\n# Calculate sensitivity of outcome to factors for each time step\nADRIA.sensitivity.tsa(rs.inputs, y_tac)\n\nArguments\n\nX : Scenario specification\ny : scenario outcomes over time\n\nReturns\n\nNamedDimsArray, of shape D ⋅ 6 ⋅ T, where\n\nD\nis the number of dimensions/factors\n6 corresponds to the min, mean, median, max, std, and cv of the PAWN indices\nT\nis the number of time steps\n\n\n\n\n\n","category":"method"},{"location":"API/#General-API","page":"ADRIA API","title":"General API","text":"","category":"section"},{"location":"API/","page":"ADRIA API","title":"ADRIA API","text":"Modules = [ADRIA]\nOrder   = [:function, :type]\nPrivate = false","category":"page"},{"location":"API/#ADRIA.coral_spec-Tuple{}","page":"ADRIA API","title":"ADRIA.coral_spec","text":"coral_spec()\n\nTemplate for coral parameter values for ADRIA. Includes \"vital\" bio/ecological parameters, to be filled with sampled or user-specified values.\n\nAny parameter added to the params DataFrame defined here will automatically be made available to the ADRIA model.\n\nNotes: Values for the historical, temporal patterns of degree heating weeks between bleaching years come from [1].\n\nReturns\n\nparams : NamedTuple[taxanames, paramnames, params], taxa names, parameter          names, and parameter values for each coral taxa, group and size class\n\nReferences\n\nLough, J. M., Anderson, K. D., & Hughes, T. P. (2018).  Increasing thermal stress for tropical coral reefs: 1871-2017.  Scientific Reports, 8(1), 6079.  https://doi.org/10.1038/s41598-018-24530-9\nHall, V.R. & Hughes, T.P. 1996. Reproductive strategies of modular organisms:   comparative studies of reef-building corals. Ecology, 77: 950 - 963. https://dx.doi.org/10.2307/2265514\nBozec, Y.-M., Rowell, D., Harrison, L., Gaskell, J., Hock, K.,  Callaghan, D., Gorton, R., Kovacs, E. M., Lyons, M., Mumby, P.,  & Roelfsema, C. (2021). Baseline mapping to support reef restoration and   resilience-based management in the Whitsundays. https://doi.org/10.13140/RG.2.2.26976.20482\nBozec, Y.-M., Hock, K., Mason, R. A. B., Baird, M. E., Castro-Sanguino, C.,  Condie, S. A., Puotinen, M., Thompson, A., & Mumby, P. J. (2022). Cumulative impacts across Australia's Great Barrier Reef: A mechanistic evaluation. Ecological Monographs, 92(1), e01494. https://doi.org/10.1002/ecm.1494\nBairos-Novak, K.R., Hoogenboom, M.O., van Oppen, M.J.H., Connolly, S.R., 2021. Coral adaptation to climate change: Meta-analysis reveals high heritability across   multiple traits. Global Change Biology 27, 5694-5710. https://doi.org/10.1111/gcb.15829\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.create_coral_struct","page":"ADRIA API","title":"ADRIA.create_coral_struct","text":"create_coral_struct(bounds=(0.9, 1.1))\n\nGenerates Coral struct using the default parameter spec.\n\nExample\n\n# Define coral struct with auto-generated parameter ranges\n# (default in ADRIA is ± 10%, triangular distribution with peak at 0.5)\ncreate_coral_struct()\ncoral = Coral()\n\n# Recreate coral spec ± 50% from nominal values\ncreate_coral_struct((0.5, 1.5))\ncoral = Coral()\n\n\n\n\n\n","category":"function"},{"location":"API/#ADRIA.env_stats-Tuple{ADRIA.ResultSet, String, String}","page":"ADRIA API","title":"ADRIA.env_stats","text":"env_stats(rs::ResultSet, s_name::String, rcp::String)\nenv_stats(rs::ResultSet, s_name::String, rcp::String, scenario::Int)\nenv_stats(rs::ResultSet, s_name::String, stat::String, rcp::String, scenario::Int)\n\nExtract statistics for a given environmental layer (\"DHW\" or \"wave\")\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.growthODE-Tuple{Matrix{Float64}, Matrix{Float64}, NamedTuple, Real}","page":"ADRIA API","title":"ADRIA.growthODE","text":"growthODE(du, X, p, _)\n\nBase coral growth function.\n\nProportion of corals within a size class are modeled to transition to the next size class up. Assumes colony sizes are evenly distributed within each size bin. Transitions are a ratio of the change in colony size to the width of the bin. See coral_spec() for further detail.\n\nNote that recruitment pertains to coral groups (n = 6) and represents the contribution to the cover of the smallest size class within each group.  While growth and mortality metrics pertain to groups (6) as well as size classes (6) across all sites (total of 36 by n_sites), recruitment is a 6 by n_sites array.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.run_scenario-Tuple{Domain, Int64, Union{DataFrames.DataFrameRow, AbstractVector}, NamedTuple, NamedTuple}","page":"ADRIA API","title":"ADRIA.run_scenario","text":"run_scenario(domain::Domain, idx::Int64, scenario::Union{AbstractVector, DataFrameRow}, data_store::NamedTuple, cache::NamedTuple)::Nothing\nrun_scenario(domain::Domain, idx::Int64, scenario::Union{AbstractVector, DataFrameRow}, domain::Domain, data_store::NamedTuple)::Nothing\nrun_scenario(domain::Domain, scenario::Union{AbstractVector, DataFrameRow}, cache::NamedTuple)::NamedTuple\nrun_scenario(domain::Domain, scenario::NamedTuple)::NamedTuple\n\nRun individual scenarios for a given domain, saving results to a Zarr data store. Results are stored in Zarr format at a pre-configured location. Sets up a new cache if not provided.\n\nNotes\n\nLogs of site ranks only store the mean site rankings over all environmental scenarios. This is to reduce the volume of data stored.\n\nReturns\n\nNothing\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.run_scenario-Tuple{Int64, Union{DataFrames.DataFrameRow, AbstractVector}, Any, Vararg{Any}}","page":"ADRIA API","title":"ADRIA.run_scenario","text":"run_scenario(idx::Int64, param_set::Union{AbstractVector, DataFrameRow}, domain::Domain, data_store::NamedTuple, cache::NamedTuple)::Nothing\nrun_scenario(idx::Int64, param_set::Union{AbstractVector, DataFrameRow}, domain::Domain, data_store::NamedTuple)::Nothing\nrun_scenario(param_set::Union{AbstractVector, DataFrameRow}, domain::Domain, cache::NamedTuple)::NamedTuple\nrun_scenario(param_set::NamedTuple, domain::Domain)::NamedTuple\n\nWARNING: Deprecated set of functions to be removed in v1.0\n\nInstead, use: run_scenario(dom, scenarios, ...)\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.select-Tuple{ADRIA.ResultSet, String}","page":"ADRIA API","title":"ADRIA.select","text":"select(r::ResultSet, op::String)\n\nHacky scenario filtering - to be replaced with more robust approach.\n\nOnly supports filtering by single attribute. Should be expanded to support filtering metric results too.\n\nExamples\n\nselect(result, \"guided .> 0.0\")\n\n# Above expands to:\n# result.inputs.guided .> 0.0\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.site_area-Tuple{ADRIA.ResultSet}","page":"ADRIA API","title":"ADRIA.site_area","text":"site_area(rs::ResultSet)::Vector{Float64}\n\nExtract vector of a location's total area in its areal unit (m², km², etc).\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.site_area-Tuple{Domain}","page":"ADRIA API","title":"ADRIA.site_area","text":"site_area(domain::Domain)::Vector{Float64}\n\nGet site area for the given domain.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.site_k_area-Tuple{ADRIA.ResultSet}","page":"ADRIA API","title":"ADRIA.site_k_area","text":"site_k_area(rs::ResultSet)::Vector{Float64}\n\nExtract vector of a location's coral carrying capacity in terms of absolute area.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.site_k_area-Tuple{Domain}","page":"ADRIA API","title":"ADRIA.site_k_area","text":"site_k_area(domain::Domain)::Vector{Float64}\n\nGet maximum coral cover area for the given domain in absolute area.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.timesteps-Tuple{ADRIA.ResultSet}","page":"ADRIA API","title":"ADRIA.timesteps","text":"timesteps(rs::ResultSet)\n\nRetrieve the time steps represented in the result set.\n\nArguments\n\nrs : ResultSet\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.timesteps-Tuple{Domain}","page":"ADRIA API","title":"ADRIA.timesteps","text":"Extract the time steps represented in the data package.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.ADRIADomain","page":"ADRIA API","title":"ADRIA.ADRIADomain","text":"ADRIADomain{Σ,M,I,D,X,Y,Z}\n\nCore ADRIA domain. Represents study area.\n\n\n\n\n\n","category":"type"},{"location":"API/#ADRIA.Domain-Tuple{String, String, String, Vector, Vararg{String, 8}}","page":"ADRIA API","title":"ADRIA.Domain","text":"Domain(name::String, rcp::String, timeframe::Vector, site_data_fn::String, site_id_col::String, unique_site_id_col::String, init_coral_fn::String, conn_path::String, dhw_fn::String, wave_fn::String, cyclone_mortality_fn::String)::Domain\n\nConvenience constructor for Domain.\n\nArguments\n\nname : Name of domain\ndpkg_path : location of data package\nrcp : RCP scenario represented\ntimeframe : Time steps represented\nsite_data_fn : File name of spatial data used\nsite_id_col : Column holding name of reef the site is associated with (non-unique)\nunique_site_id_col : Column holding unique site names/ids\ninit_coral_fn : Name of file holding initial coral cover values\nconn_path : Path to directory holding connectivity data\ndhw_fn : Filename of DHW data cube in use\nwave_fn : Filename of wave data cube\ncyclone_mortality_fn : Filename of cyclone mortality data cube\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.Domain-Union{Tuple{T}, Tuple{String, String, ADRIA.EnvLayer, AbstractMatrix{<:T}, Vector{Float64}, Vector{Float64}, Vector{Int64}, DataFrames.DataFrame, String, String, NamedDims.NamedDimsArray, ADRIA.CoralGrowth, Vector{String}, Vector{String}, NamedDims.NamedDimsArray, NamedDims.NamedDimsArray, NamedDims.NamedDimsArray}} where T<:Union{Float32, Float64}","page":"ADRIA API","title":"ADRIA.Domain","text":"Barrier function to create Domain struct without specifying Intervention/Criteria/Coral/SimConstant parameters.\n\n\n\n\n\n","category":"method"},{"location":"API/#ADRIA.SimConstants","page":"ADRIA API","title":"ADRIA.SimConstants","text":"SimConstants\n\nStruct of simulation constants for ADRIA\n\nReferences\n\nLough, J. M., Anderson, K. D., & Hughes, T. P. (2018). Increasing thermal stress for tropical coral reefs: 1871-2017. Scientific Reports, 8(1), 6079. https://doi.org/10.1038/s41598-018-24530-9\nHughes, T. P., Kerry, J. T., Baird, A. H., Connolly, S. R.,   Dietzel, A., Eakin, C. M., Heron, S. F., Hoey, A. S.,   Hoogenboom, M. O., Liu, G., McWilliam, M. J., Pears, R. J.,   Pratchett, M. S., Skirving, W. J., Stella, J. S., & Torda, G. (2018). Global warming transforms coral reef assemblages. Nature, 556(7702), 492-496. https://doi.org/10.1038/s41586-018-0041-2\nBozec, Y.-M., Rowell, D., Harrison, L., Gaskell, J., Hock, K.,   Callaghan, D., Gorton, R., Kovacs, E. M., Lyons, M., Mumby, P.,   & Roelfsema, C. (2021). Baseline mapping to support reef restoration and   resilience-based management in the Whitsundays. https://doi.org/10.13140/RG.2.2.26976.20482\nBozec, Y.-M., Hock, K., Mason, R. A. B., Baird, M. E., Castro-Sanguino, C.,   Condie, S. A., Puotinen, M., Thompson, A., & Mumby, P. J. (2022). Cumulative impacts across Australia's Great Barrier Reef: A mechanistic evaluation. Ecological Monographs, 92(1), e01494. https://doi.org/10.1002/ecm.1494\n\n\n\n\n\n","category":"type"},{"location":"development/building_docs/#Building-Documentation","page":"Building Documentation","title":"Building Documentation","text":"","category":"section"},{"location":"development/building_docs/","page":"Building Documentation","title":"Building Documentation","text":"ADRIA documentation is built using Documenter.jl.","category":"page"},{"location":"development/building_docs/#Building-documentation-locally","page":"Building Documentation","title":"Building documentation locally","text":"","category":"section"},{"location":"development/building_docs/","page":"Building Documentation","title":"Building Documentation","text":"As the documentation is build from a separate environment, it must be maintained/updated to incorporate any changes to ADRIA.","category":"page"},{"location":"development/building_docs/","page":"Building Documentation","title":"Building Documentation","text":"$ julia --project=docs\n(docs) pkg> resolve\n(docs) pkg> up","category":"page"},{"location":"development/building_docs/","page":"Building Documentation","title":"Building Documentation","text":"If no changes to the environment are necessary, simply run make.jl from the docs folder:","category":"page"},{"location":"development/building_docs/","page":"Building Documentation","title":"Building Documentation","text":"$ cd docs\n$ julia --project=. make.jl","category":"page"},{"location":"development/building_docs/","page":"Building Documentation","title":"Building Documentation","text":"Locally generated documentation can be found under docs/build. Open the index.html file with any web browser.","category":"page"},{"location":"development/building_docs/#Documentation-deployment","page":"Building Documentation","title":"Documentation deployment","text":"","category":"section"},{"location":"development/building_docs/","page":"Building Documentation","title":"Building Documentation","text":"Documentation is hosted on GitHub Pages via GitHub Actions.","category":"page"},{"location":"development/building_docs/","page":"Building Documentation","title":"Building Documentation","text":"Configuration is found here.","category":"page"},{"location":"development/building_docs/","page":"Building Documentation","title":"Building Documentation","text":"Documentation is automatically built and deployed:","category":"page"},{"location":"development/building_docs/","page":"Building Documentation","title":"Building Documentation","text":"When a PR targeting main is submitted   In this case, a preview URL is created: e.g., a URL with previews/PR### at the end, where PR### refers to the PR ID.\nOn commit/merge to main   In this case the main documentation website is updated","category":"page"},{"location":"usage/analysis/#Analysis","page":"Analysis","title":"Analysis","text":"","category":"section"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"This section presents tools for analysing model generate data, including functions to extract metrics and plot graphs.","category":"page"},{"location":"usage/analysis/#Setup","page":"Analysis","title":"Setup","text":"","category":"section"},{"location":"usage/analysis/#Makie","page":"Analysis","title":"Makie","text":"","category":"section"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"The Makie.jl ecosystem is used to produce figures.","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"Install additional packages if necessary","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"]add Makie GeoMakie GraphMakie","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"Install a Makie backend of your choice. WGLMakie is more flexible for our workflows, but GLMakie is a good choice too.","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"]add WGLMakie","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"Import additional packages and the visualization extension will compile.","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"using WGLMakie, GeoMakie, GraphMakie\nusing ADRIA\nusing Statistics","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"Plots will appear in the VS Code plots pane. You may need to deactivate the inline plotting feature when displaying plots elsewhere.","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"Makie.inline!(false)","category":"page"},{"location":"usage/analysis/#Result-Set","page":"Analysis","title":"Result Set","text":"","category":"section"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"All metrics and visualization tools presented here can be used with data generated from ADRIAmod. Following, we show usage examples considering ADRIA result set rs:","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"# Load domain data\ndom = ADRIA.load_domain(\"path to domain data\")\n\n# Create some scenarios\nnum_samples = 4096\nscens = ADRIA.sample(dom, num_samples)\n\n# Run the model for generated scenarios\nrcp_45 = \"45\"\nrs = ADRIA.run_scenarios(dom, scens, rcp_45)\n\n# Visualize results (in terms of absolute coral cover)\ns_tac = ADRIA.metrics.scenario_total_cover(rs)\nADRIA.viz.scenarios(rs, s_tac)","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"See the previous sections Loading a Domain, Generating scenarios and Running scenarios for more information.","category":"page"},{"location":"usage/analysis/#Extracting-results","page":"Analysis","title":"Extracting results","text":"","category":"section"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"A range of metrics are defined as part of the ADRIA framework. See the Metrics page for more details.","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"Here, we extract results for specific metrics for each timestep and sites for all the scenarios run. The result of each line above is a 3-dimensional Array of timesteps, sites and scenarios:","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"tac = ADRIA.metrics.total_absolute_cover(rs)\nrsv = ADRIA.metrics.relative_shelter_volume(rs)\njuves = ADRIA.metrics.relative_juveniles(rs)","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"We can also look at scenario-level metrics. They aggregate the above metrics across the site dimension and indicate the outcomes under a given intervention (or non-intervention) option and environmental condition.","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"The result is a 2-dimensional array of timesteps and scenarios:","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"s_tac = ADRIA.metrics.scenario_total_cover(rs)\ns_rsv = ADRIA.metrics.scenario_rsv(rs)\ns_juves = ADRIA.metrics.scenario_relative_juveniles(rs)","category":"page"},{"location":"usage/analysis/#Visualization","page":"Analysis","title":"Visualization","text":"","category":"section"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"The examples below are to illustrate usage. For further information on each method of analysis, see the documentation for the given function.","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"Some options shared for the plots below are defined here.","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"# Some shared options for the example plots below\nfig_opts = Dict(:resolution => (1600, 800))\n\n# Factors of Interest\nopts = Dict(\n    :factors => [\n        :RCP,\n        :dhw_scenario,\n        :wave_scenario,\n        :guided,\n        :N_seed_TA,\n        :N_seed_CA,\n        :fogging,\n        :SRM,\n        :a_adapt\n    ]\n)","category":"page"},{"location":"usage/analysis/#Scenario-outcomes","page":"Analysis","title":"Scenario outcomes","text":"","category":"section"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"One can plot a quick scenario overview:","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"fig_s_tac = ADRIA.viz.scenarios(\n    rs, s_tac; fig_opts=fig_opts, axis_opts=Dict(:ylabel => \"Scenario Total Cover\")\n)\nsave(\"scenarios_tac.png\", fig_s_tac)","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"(Image: Quick scenario plots)","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"And compose a figure with subplots. In the example below we also use the parameter opts that accepts the keys by_RCP to group scenarios by RCP (default is false), legend to plot the legend (default is true) and summarize to plot confidence intervals instead of plotting each series (default is true):","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"tf = Figure(resolution=(1600, 600))  # resolution in pixels\n\n# Implicitly create a single figure with 2 columns\nADRIA.viz.scenarios!(\n    tf[1, 1],\n    rs,\n    s_tac;\n    opts=Dict(:by_RCP => false, :legend => false),\n    axis_opts=Dict(:title => \"TAC [m²]\"),\n);\nADRIA.viz.scenarios!(\n    tf[1, 2],\n    rs,\n    s_juves;\n    opts=Dict(:summarize => false),\n    axis_opts=Dict(:title => \"Juveniles [%]\"),\n);\n\ntf  # display the figure\nsave(\"aviz_scenario.png\", tf)  # save the figure to a file","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"(Image: Scenarios with subplots)","category":"page"},{"location":"usage/analysis/#Intervention-location-selection-visualisation","page":"Analysis","title":"Intervention location selection - visualisation","text":"","category":"section"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"Plot spatial colormaps of site selection frequencies and other available site selection metrics.","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"# Calculate frequencies with which each site was selected at each rank\nrank_freq = ADRIA.decision.ranks_to_frequencies(\n    rs.ranks[intervention=1];\n    agg_func=x -> dropdims(sum(x; dims=:timesteps); dims=:timesteps),\n)\n\n# Plot 1st rank frequencies as a colormap\nrank_fig = ADRIA.viz.ranks_to_frequencies(rs, rank_freq, 1; fig_opts=Dict(:resolution=>(1200, 800)))\n\nsave(\"single_rank_plot.png\", rank_fig)","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"(Image: Rank frequency plots for single rank)","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"# Plot 1st, 2nd and 3rd rank frequencies as an overlayed colormap\nrank_fig = ADRIA.viz.ranks_to_frequencies(rs, rank_freq, [1, 2, 3]; fig_opts=Dict(:resolution=>(1200, 800)))\n\nsave(\"ranks_plot.png\", rank_fig)","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"(Image: Rank frequency plots for multiple ranks)","category":"page"},{"location":"usage/analysis/#PAWN-sensitivity-(heatmap-overview)","page":"Analysis","title":"PAWN sensitivity (heatmap overview)","text":"","category":"section"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"The PAWN sensitivity analysis method is a moment-independent approach to Global Sensitivity Analysis. It is described as producing robust results at relatively low sample sizes, and is used to screen factors (i.e., identification of important factors) and rank factors as well (ordering factors by their relative contribution towards a given quantity of interest).","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"# Sensitivity (of mean scenario outcomes to factors)\nmean_s_tac = vec(mean(s_tac, dims=1))\ntac_Si = ADRIA.sensitivity.pawn(rs, mean_s_tac)\npawn_fig = ADRIA.viz.pawn(\n    tac_Si;\n    opts,\n    fig_opts\n)\nsave(\"pawn_si.png\", pawn_fig)","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"(Image: PAWN sensitivity plots)","category":"page"},{"location":"usage/analysis/#Temporal-Sensitivity-Analysis","page":"Analysis","title":"Temporal Sensitivity Analysis","text":"","category":"section"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"Temporal (or Time-varying) Sensitivity Analysis applies sensitivity analysis to model outputs over time. The relative importance of factors and their influence on outputs over time can then be examined through this analysis.","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"tsa_s = ADRIA.sensitivity.tsa(rs, s_tac)\ntsa_fig = ADRIA.viz.tsa(\n    rs,\n    tsa_s;\n    opts,\n    fig_opts\n)\nsave(\"tsa.png\", tsa_fig)","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"(Image: Plots of Temporal Sensitivities)","category":"page"},{"location":"usage/analysis/#Convergence-Analysis","page":"Analysis","title":"Convergence Analysis","text":"","category":"section"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"When undertaking sensitivity analysis it is important to have a sufficient number of samples such that the sensitivity measure converges to a stable state. To assess whether sufficient samples have been taken a convergence analysis can be conducted. One approach is to draw a large sample and then iteratively assess stability of the sensitivity metric using an increasing number of sub-samples. The sensitivity metric is described as having \"converged\" if there is little to no fluctuations/variance for a given sample size. The analysis can help determine if too little (or too many) samples have taken for the purpose of sensitivity analysis.","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"The function sensitivity.convergence can be used to calculate a sensitivity measure for an increasing number of samples. The result can then be plotted as band plots or a heat map using viz.convergence.","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"outcome = dropdims(mean(ADRIA.metrics.scenario_total_cover(rs); dims=:timesteps), dims=:timesteps)\n\n# Display convergence for specific factors of interest (\"foi\") within a single figure.\n# Bands represent the 95% confidence interval derived from the number of conditioning\n# points, the default for which is ten (i.e., 10 samples).\n# Due to the limited sample size, care should be taken when interpreting the figure.\nfoi = [:dhw_scenario, :wave_scenario, :guided]\nSi_conv = ADRIA.sensitivity.convergence(scens, outcome, foi)\nconv_series_fig = ADRIA.viz.convergence(Si_conv, foi)\nsave(\"convergence_factors_series.png\", conv_series_fig)\n\n# Convergence analysis of factors grouped by model component as a heat map\ncomponents = [:EnvironmentalLayer, :Intervention, :Coral]\nSi_conv = ADRIA.sensitivity.convergence(rs, scens, outcome, components)\nconv_hm_fig = ADRIA.viz.convergence(Si_conv, components; opts=Dict(:viz_type=>:heatmap))\nsave(\"convergence_components_heatmap.png\", conv_hm_fig)","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"(Image: Convergence analysis of factors overlayed) (Image: Grouped convergence analysis)","category":"page"},{"location":"usage/analysis/#Time-Series-Clustering","page":"Analysis","title":"Time Series Clustering","text":"","category":"section"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"The Time Series Clustering algorithm clusters together series (typically time series) with similar behavior. This is achieved by computing the Euclidian distance between each pair of series weighted by a correlation factor that takes into account the quotient between their complexities. When plotting clustered_scenarios, the kwarg opts can be used with the key :summarize to plot the confidence intervals of each cluster instead of each series individually (default is true).","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"# Extract metric from scenarios\ns_tac = ADRIA.metrics.scenario_total_cover(rs)\n\n# Cluster scenarios\nn_clusters = 4\nclusters = ADRIA.analysis.cluster_scenarios(s_tac, n_clusters)\n\naxis_opts = Dict(\n    :title => \"Time Series Clustering with $n_clusters clusters\",\n    :ylabel => \"TAC [m²]\",\n    :xlabel => \"Timesteps [years]\",\n)\n\ntsc_fig = ADRIA.viz.clustered_scenarios(\n    s_tac, clusters; opts=Dict(:summarize => true), fig_opts=fig_opts, axis_opts=axis_opts\n)\n\n# Save final figure\nsave(\"tsc.png\", tsc_fig)","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"(Image: Plots of Time Series Cluster)","category":"page"},{"location":"usage/analysis/#Target-clusters","page":"Analysis","title":"Target clusters","text":"","category":"section"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"One can also target scenarios that belong to specific clusters (like clusters with higher median value for some outcome):","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"# Extract metric from scenarios\nasv = ADRIA.metrics.absolute_shelter_volume(rs)\n\n# Time series summarizing scenarios for each site\nasv_site_series = ADRIA.metrics.loc_trajectory(median, asv)\n\n# Cluster scenarios\nn_clusters = 6\nasv_clusters = ADRIA.analysis.cluster_scenarios(asv_site_series, n_clusters)\n\n# Target scenarios that belong to the two lowest value clusters\nlowest = x -> x .∈ [sort(x; rev=true)[1:2]]\nasv_target = ADRIA.analysis.find_scenarios(asv_site_series, asv_clusters, lowest)\n\n# Plot targeted scenarios\naxis_opts = Dict(:ylabel => \"Absolute Shelter Volume\", :xlabel => \"Timesteps [years]\")\n\ntsc_asc_fig = ADRIA.viz.clustered_scenarios(\n    asv_site_series, asv_target; axis_opts=axis_opts, fig_opts=fig_opts\n)\n\n# Save final figure\nsave(\"tsc_asv.png\", tsc_asc_fig)","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"(Image: Plots of targeted lowest clusters)","category":"page"},{"location":"usage/analysis/#Multiple-Time-Series-Clustering","page":"Analysis","title":"Multiple Time Series Clustering","text":"","category":"section"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"It is possible to perform time series clustering for different metric outcomes and find scenarios that behave the same across all of them. Currently there is no visualization function for this.","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"metrics::Vector{ADRIA.metrics.Metric} = [\n    ADRIA.metrics.scenario_total_cover,\n    ADRIA.metrics.scenario_asv,\n    ADRIA.metrics.scenario_absolute_juveniles,\n]\n\noutcomes = ADRIA.metrics.scenario_outcomes(rs, metrics)\nn_clusters = 6\n\n# Clusters matrix\noutcomes_clusters::AbstractMatrix{Int64} = ADRIA.analysis.cluster_scenarios(\n    outcomes, n_clusters\n)\n\n# Filter scenarios that belong to on of the 4 high value clusters for all outcomes\nhighest_clusters(x) = x .∈ [sort(x; rev=true)[1:4]]\nrobust_scens = ADRIA.analysis.find_scenarios(outcomes, outcomes_clusters, highest_clusters)","category":"page"},{"location":"usage/analysis/#Time-Series-Clustering-Map","page":"Analysis","title":"Time Series Clustering Map","text":"","category":"section"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"When using Time Series Clustering to cluster among multiple locations using some metric, it is possible to visualize the result as a map.","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"# Extract metric from scenarios\ntac = ADRIA.metrics.total_absolute_cover(rs)\n\n# Get a timeseries summarizing the scenarios for each site\ntac_site_series = ADRIA.metrics.loc_trajectory(median, tac)\n\n# Cluster scenarios\nn_clusters = 6\nclusters = ADRIA.analysis.cluster_scenarios(tac_site_series, n_clusters)\n\n# Get a vector summarizing the scenarios and timesteps for each site\ntac_sites = ADRIA.metrics.per_loc(median, tac)\n\n# Plot figure\ntsc_map_fig = ADRIA.viz.map(rs, tac_sites, clusters)\n\n# Save final figure\nsave(\"tsc_map.png\", tsc_map_fig)","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"(Image: Plots of Spatial Time Series Clusters)","category":"page"},{"location":"usage/analysis/#Rule-Induction-(using-Series-Clusters)","page":"Analysis","title":"Rule Induction (using Series Clusters)","text":"","category":"section"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"After clustering, it is possible to target some specific scenarios based on each cluster median outcome temporal variability:","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"# Find Time Series Clusters\ns_tac = ADRIA.metrics.scenario_total_cover(rs)\nnum_clusters = 6\nclusters = ADRIA.analysis.cluster_scenarios(s_tac, num_clusters)\n\n# Target scenarios\ntarget_clusters = ADRIA.analysis.target_clusters(clusters, s_tac)","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"Using this vector if target clusters, together with the parameters used to generate each scenario, it is possible to use a Rule Induction algorithm (SIRUS) and plot each extracted rule as a scatter graph:","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"# Select only desired features\nfields_iv = ADRIA.component_params(rs, [Intervention, CriteriaWeights]).fieldname\nscenarios_iv = scens[:, fields_iv]\n\n# Use SIRUS algorithm to extract rules\nmax_rules = 10\nrules_iv = ADRIA.analysis.cluster_rules(target_clusters, scenarios_iv, max_rules)\n\n# Plot scatters for each rule highlighting the area selected them\nrules_scatter_fig = ADRIA.viz.rules_scatter(\n    rs,\n    scenarios_iv,\n    target_clusters,\n    rules_iv;\n    fig_opts=fig_opts,\n    opts=opts\n)\n\n# Save final figure\nsave(\"rules_scatter.png\", rules_scatter_fig)","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"(Image: Plots of Rule Induction)","category":"page"},{"location":"usage/analysis/#Regional-Sensitivity-Analysis","page":"Analysis","title":"Regional Sensitivity Analysis","text":"","category":"section"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"Regional Sensitivity Analysis is a monte-carlo filtering approach. The aim of RSA is to aid in identifying which (group of) factors drive model outputs and their active areas of factor space.","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"tac_rs = ADRIA.sensitivity.rsa(rs, mean_s_tac; S=10)\nrsa_fig = ADRIA.viz.rsa(\n    rs,\n    tac_rs,\n    [\"dhw_scenario\", \"wave_scenario\", \"N_seed_TA\", \"N_seed_CA\", \"fogging\", \"SRM\"];\n    opts,\n    fig_opts\n)\nsave(\"rsa.png\", rsa_fig)","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"(Image: Plots of Regional Sensitivities)","category":"page"},{"location":"usage/analysis/#Outcome-mapping","page":"Analysis","title":"Outcome mapping","text":"","category":"section"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"A monte-carlo filtering approach similar to Regional Sensitivity Analysis.","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"As the name implies, outcome mapping aids in identifying the relationship between model outputs and the region of factor space that led to those outputs.","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"tf = Figure(resolution=(1600, 1200))  # resolution in pixels\n\n# Indicate factor values that are in the top 50 percentile\ntac_om_50 = ADRIA.sensitivity.outcome_map(rs, mean_s_tac, x -> any(x .>= 0.5), foi; S=20)\nADRIA.viz.outcome_map!(\n    tf[1, 1],\n    rs,\n    tac_om_50,\n    foi;\n    axis_opts=Dict(:title => \"Regions which lead to Top 50th Percentile Outcomes\", :ylabel => \"TAC [m²]\")\n)\n\n# Indicate factor values that are in the top 30 percentile\ntac_om_70 = ADRIA.sensitivity.outcome_map(rs, mean_s_tac, x -> any(x .>= 0.7), foi; S=20)\nADRIA.viz.outcome_map!(\n    tf[2, 1],\n    rs,\n    tac_om_70,\n    foi;\n    axis_opts=Dict(:title => \"Regions which lead to Top 30th Percentile Outcomes\", :ylabel => \"TAC [m²]\"))\n\nsave(\"outcome_map.png\", tf)","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"(Image: Outcome mapping)","category":"page"},{"location":"usage/analysis/#GUI-for-high-level-exploration-(prototype-only!)","page":"Analysis","title":"GUI for high-level exploration (prototype only!)","text":"","category":"section"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"# To explore results interactively\nADRIA.viz.explore(\"path to Result Set\")\n\n# or, if the result set is already loaded:\n# ADRIA.viz.explore(rs)","category":"page"},{"location":"usage/analysis/","page":"Analysis","title":"Analysis","text":"(Image: Standalone app for data exploration)","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#What-is-ADRIA.jl?","page":"Introduction","title":"What is ADRIA.jl?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"ADRIA is a decision support platform for informing reef restoration and adaptation interventions through scenario exploration and analysis, decision heuristics (MCDA), alongside a small coral ecosystem model.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Among the most common usecases are:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Running a number of scenarios under different environmental and intervention conditions (see Loading a Domain, Generating scenarios and Running scenarios);\nExtracting metrics for each scenario and timestep such as coral cover, shelter volume or number of juveniles (see Metrics);\nUsing these metrics to perform a range of analyses like time series clustering (grouping together scenarios with similar temporal behaviour; see Analysis);\nUsing the visualization tools to plot some of the mentioned metrics or analysis (see Analysis);","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"More details about each of these can be found in the next sections.","category":"page"},{"location":"#Troubleshooting-F.A.Q","page":"Introduction","title":"Troubleshooting F.A.Q","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"ADRIA.jl is under active development and from time to time issues may arise. Here are some answers to some issues encountered.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Q. I get this warning when trying to load pre-existing results:   Results were produced with a different version of ADRIA (v0.x.x). The installed version of ADRIA is: v0.y.y. Errors may occur when analyzing data.   (where x and y are different numbers).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A. The result set being loaded were generated by a different version of ADRIA, and in a possibly incompatible format.   Sometimes, results may still be produced/analyzed as normal. In other times, ADRIA.jl or the expected metadata in the result set may have changed   leading to errors when conducting analyses.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Either go back to the version indicated, or re-run the scenarios to obtain results in the updated format.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Q. I get an error or warning about an ENV variable not being found or set.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A. Double check the configuration settings in config.toml (see above).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Q. How do I run my own scenarios?","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A. Scenarios are defined in a CSV file (with parameter values in columns, so that each row defines a scenario).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"See the example_scenarios.csv file in the ADRIA data specification repository for an idea of what this looks like.\nSee Extracting model details example in Cookbook examples on how to extract the model specification and parameter table for a given domain.\nSee also the Generating and running scenarios example in Cookbook examples which showcases how to run such a file for a given study area.","category":"page"},{"location":"usage/scenario_discovery/#Scenario-Discovery","page":"Scenario Discovery","title":"Scenario Discovery","text":"","category":"section"},{"location":"usage/scenario_discovery/","page":"Scenario Discovery","title":"Scenario Discovery","text":"using ADRIA\n\ndom = ADRIA.load_domain(\"...\")\nscens = ADRIA.sample(dom, 4096)\n\nrs = ADRIA.run_scenarios(dom, scens, \"45\")\n# rs = ADRIA.load_results(\"...\")\n\n# Calculate representative statistic for all metrics of interest\n# Here, total cover, shelter volume and juvenile population\ntac = ADRIA.metrics.scenario_total_cover(rs)\nmean_tac = vec(mean(tac, dims=1))\n\nrsv = ADRIA.metrics.scenario_rsv(rs)\nmean_sv = vec(mean(rsv, dims=1))\n\nr_juves = ADRIA.metrics.scenario_relative_juveniles(rs)\nmean_juves = vec(mean(r_juves, dims=1))\n\n# Create matrix of all metrics\ny = hcat(mean_tac, mean_sv, mean_juves)\n\n# Define \"robust scenario\" as one where all metric outcomes >= 30th percentile.\nrule_func = x -> all(x .>= 0.3)\n\n# Identify robust scenarios for a specific RCP (4.5)\nrobust = ADRIA.analysis.find_robust(rs, y, rule_func, [45])\n\n# Output robust scenario IDs\n@info robust.RCP45\n\n# Could qualitatively examine inputs that led to robust scenarios ...\nrs.inputs[robust.RCP45, :]\n\n# ... or mark behavioural and non-behavioural outcomes for further analysis\n# e.g., with random forest.\nbehave = zeros(size(y, 1))\nbehave[robust.RCP45] .= 1.0\n\n# Next step is to test these for robustness across environmental conditions ...\n# [TODO]","category":"page"}]
}
